{"file_contents":{"replit.md":{"content":"# Advanced Discord Ticket Bot\n\n## Project Overview\nA modern, production-ready Discord ticket support system with comprehensive features including multi-language support, automation, analytics, AI responses, and full customization. Built with TypeScript and discord.js v14.15+.\n\n## Current State - v2.0 (Production-Ready)\n### ‚úÖ Core Features\n- Complete modular architecture with TypeScript strict mode\n- Multi-language system with YAML-based translations (lang/ folder)\n- Comprehensive YAML configuration (config.yml) with all features\n- Environment variable support with .env files for security\n- Docker deployment ready (Dockerfile + docker-compose.yml)\n- Comprehensive README with full documentation\n\n### ‚úÖ Ticket Management\n- Ticket panels with dropdown categories (ticket-panels.yml)\n- Dynamic modal forms with custom questions\n- **Priority system** (Low, Medium, High, Urgent) with colored labels\n- **Ticket claiming** for staff ownership tracking\n- **Advanced tagging** system for categorization\n- Member add/remove functionality\n- Private ticket channels with proper permissions\n\n### ‚úÖ Automation & Intelligence\n- **Auto-close system** after configurable inactivity period\n- **Inactivity warnings** sent before auto-close\n- **Staff reminders** for unanswered tickets\n- **Working hours** enforcement with timezone support\n- **Ticket overload detection** and alerts\n- **AI auto-responses** (optional, ready for integration)\n\n### ‚úÖ Analytics & Reporting\n- **Statistics dashboard** (/stats command)\n- **Comprehensive logging** with file and Discord channel logging\n- **Staff performance tracking** (tickets handled, response times)\n- **Customer feedback system** (1-5 star ratings)\n- **Beautiful transcripts** (HTML and TXT formats)\n- **Audit logs** (/logs command) for all ticket actions\n\n### ‚úÖ Utilities & Tools\n- TicketManager - Core ticket operations\n- Logger - File and Discord logging\n- StatsManager - Analytics and metrics\n- AutomationManager - Background automation tasks\n- TranscriptGenerator - Modern HTML/TXT transcripts\n- AddonManager - Custom module loading system\n- LanguageManager - Multi-language support\n- EnvLoader - Secure environment variable loading\n- ConfigHandler - YAML + env var configuration\n\n### ‚úÖ Commands Implemented\n**Admin Commands:**\n- /ticket panel - Send ticket panels\n- /ticket add/remove - Manage ticket members\n- /stats - View comprehensive statistics\n- /logs [limit] - View audit logs\n- /settings - Interactive settings menu\n- /blacklist add/remove/list - Manage blacklist\n\n**Staff Commands:**\n- /claim ticket/unclaim - Claim/unclaim tickets\n- /priority <level> - Set ticket priority\n- /tag add/remove/list - Manage ticket tags\n- /close [reason] - Close tickets\n- /transcript - Generate transcript\n- /feedback view - View feedback\n\n**General:**\n- /reload - Reload configuration\n\n## Setup Instructions\n\n### 1. Environment Configuration\n```bash\n# Copy the environment template\ncp .env.example .env\n\n# Edit .env with your Discord bot credentials\nnano .env\n```\n\n### 2. Required Environment Variables\n- `DISCORD_TOKEN` - Your Discord bot token\n- `GUILD_ID` - Your Discord server ID\n- `TICKET_CATEGORY_ID` - Category for ticket channels\n- `FEEDBACK_CHANNEL_ID` - Channel for feedback\n- `TRANSCRIPT_CHANNEL_ID` - Channel for transcripts\n- `LOG_CHANNEL_ID` - Channel for audit logs\n- `STAFF_ROLES` - Comma-separated staff role IDs\n\n### 3. Bot Permissions\nRequired Discord permissions:\n- Manage Channels\n- Send Messages\n- Embed Links\n- Attach Files\n- Read Message History\n- Manage Messages\n- Use Application Commands\n\n### 4. Start the Bot\n**Option A - Standard:**\n```bash\nnpm install\nnpm start\n```\n\n**Option B - Docker:**\n```bash\ndocker-compose up -d\n```\n\n## Technical Architecture\n\n**Stack:**\n- Node.js v20+\n- TypeScript 5.9+ (strict mode, ES modules)\n- discord.js 14.15+\n- js-yaml for YAML configuration\n- chalk for colored console output\n- date-fns for date formatting\n\n**Project Structure:**\n```\nsrc/\n‚îú‚îÄ‚îÄ commands/      # Slash command handlers\n‚îú‚îÄ‚îÄ events/        # Discord event handlers\n‚îú‚îÄ‚îÄ utils/         # Utility managers\n‚îî‚îÄ‚îÄ types/         # TypeScript type definitions\nlang/              # Language files (en.yml, etc.)\naddons/            # Custom addon modules\ndata/              # Persistent JSON data\nlogs/              # Log files\ntranscripts/       # Generated transcripts\n```\n\n**Design Patterns:**\n- Modular command system with dynamic loading\n- Event-driven interaction handling\n- Singleton utility managers\n- Factory pattern for ticket creation\n- Observer pattern for automation monitoring\n\n## Configuration Files\n\n**config.yml** - Main configuration\n- Discord settings (loaded from .env for security)\n- Branding (colors, footer, bot name)\n- Feature toggles\n- Automation settings\n- Working hours schedule\n- Priority colors\n- Available tags\n\n**ticket-panels.yml** - Ticket panel definitions\n- Panel layouts and embeds\n- Categories with labels and emojis\n- Modal forms with custom questions\n\n**lang/en.yml** - Language translations\n- All user-facing text\n- Easily translatable to other languages\n\n## Security Features\n\n- ‚úÖ **Environment variables** - Secrets never in version control\n- ‚úÖ **EnvLoader utility** - Secure .env file parsing\n- ‚úÖ **Config validation** - Prevents insecure startup\n- ‚úÖ **Blacklist system** - Prevent abusive users\n- ‚úÖ **Permission checks** - Role-based access control\n- ‚úÖ **Audit logging** - All actions tracked\n- ‚úÖ **.gitignore** - Protects sensitive data and logs\n\n## Deployment\n\n**Production Checklist:**\n1. ‚úÖ Set all environment variables in .env\n2. ‚úÖ Rotate any previously exposed Discord tokens\n3. ‚úÖ Configure config.yml with your branding\n4. ‚úÖ Set up ticket-panels.yml with your categories\n5. ‚úÖ Invite bot with proper permissions\n6. ‚úÖ Run `npm start` or `docker-compose up -d`\n7. ‚úÖ Monitor logs for successful startup\n8. ‚úÖ Test ticket creation and all features\n\n**Docker Deployment:**\n- Dockerfile with Node.js 20 Alpine\n- docker-compose.yml for easy orchestration\n- Volume mounts for persistent data\n- Environment variable injection\n- Health checks and logging\n\n## Addon System\n\nCreate custom addons in `/addons` directory:\n\n```javascript\n// addons/my-addon.js\nexport default {\n  name: 'My Addon',\n  version: '1.0.0',\n  description: 'Custom functionality',\n  author: 'Your Name',\n  \n  async onLoad(client) {\n    // Initialize addon\n  },\n  \n  async onUnload() {\n    // Cleanup\n  }\n};\n```\n\n## Notes for Maintenance\n\n- **Environment Variables** - Always use .env for sensitive data, never hardcode in config.yml\n- **LSP Errors** - Some TypeScript type warnings about Discord.js types are false positives and don't affect runtime\n- **Data Storage** - JSON files in data/ directory, automatically created on first run\n- **Logging** - Both file-based (logs/) and Discord channel logging available\n- **Transcripts** - Saved in transcripts/ directory, beautiful HTML format by default\n- **Automation** - Background monitoring runs every minute when enabled\n- **Addons** - Dynamically loaded on startup if features.addons is enabled\n- **Config Reload** - Use /reload command to reload config.yml and ticket-panels.yml without restart\n\n## Future Roadmap\n\nPotential enhancements:\n- Web dashboard for configuration\n- Advanced analytics graphs\n- Multi-server support\n- SLA tracking\n- Scheduled reports\n- External ticketing API integrations (Zendesk, Freshdesk)\n\n---\n\n**Version:** 2.0  \n**Status:** Production-Ready  \n**Security:** Environment Variable Based  \n**Architecture:** Modular, Scalable, Extensible\n","size_bytes":7544},"src/commands/transcript.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n  TextChannel,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { TranscriptGenerator } from '../utils/transcriptGenerator.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('transcript')\n  .setDescription('Generate a transcript for the current ticket')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n    if (!ticket) {\n      await interaction.reply({\n        content: '‚ùå This channel is not a ticket.',\n        ephemeral: true,\n      });\n      return;\n    }\n\n    await interaction.reply({\n      content: '‚åõ Generating transcript...',\n      ephemeral: true,\n    });\n\n    const config = ConfigHandler.getConfig();\n    const channel = interaction.channel as TextChannel;\n\n    const htmlPath = await TranscriptGenerator.generateHTMLTranscript(\n      channel,\n      ticket.ticketId\n    );\n    const txtPath = await TranscriptGenerator.generateTextTranscript(\n      channel,\n      ticket.ticketId\n    );\n\n    if (htmlPath || txtPath) {\n      const files = [];\n      if (htmlPath) files.push(htmlPath);\n      if (txtPath) files.push(txtPath);\n\n      const embed = new EmbedBuilder()\n        .setTitle('üìú Transcript Generated')\n        .setDescription(\n          `**Ticket:** ${ticket.ticketId}\\n**User:** <@${ticket.data.userId}>\\n**Category:** ${ticket.data.category}`\n        )\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.followUp({\n        embeds: [embed],\n        files: files,\n        ephemeral: true,\n      });\n\n      console.log(chalk.green(`‚úÖ Transcript generated for ${ticket.ticketId}`));\n    } else {\n      await interaction.followUp({\n        content: '‚ùå Failed to generate transcript.',\n        ephemeral: true,\n      });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in transcript command:'), error);\n    await interaction.followUp({\n      content: '‚ùå An error occurred while generating the transcript.',\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":2394},"src/utils/ticketManager.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport {\n  Guild,\n  TextChannel,\n  User,\n  ChannelType,\n  PermissionFlagsBits,\n  EmbedBuilder,\n  ActionRowBuilder,\n  ButtonBuilder,\n  ButtonStyle,\n  Client,\n} from 'discord.js';\nimport { ConfigHandler } from './configHandler.js';\nimport { TicketData, TicketPriority, TicketStatus, TicketMessage } from '../types/index.js';\nimport { Lang } from './languageManager.js';\nimport { Logger } from './logger.js';\nimport { LogType } from '../types/index.js';\nimport chalk from 'chalk';\n\ninterface TicketsDatabase {\n  [ticketId: string]: TicketData;\n}\n\nexport class TicketManager {\n  private static ticketsPath = path.join(process.cwd(), 'data', 'tickets.json');\n\n  static {\n    const dir = path.dirname(this.ticketsPath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n  }\n\n  private static loadTickets(): TicketsDatabase {\n    try {\n      if (!fs.existsSync(this.ticketsPath)) {\n        fs.writeFileSync(this.ticketsPath, '{}');\n        return {};\n      }\n      const data = fs.readFileSync(this.ticketsPath, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading tickets:'), error);\n      return {};\n    }\n  }\n\n  private static saveTickets(tickets: TicketsDatabase): void {\n    try {\n      fs.writeFileSync(this.ticketsPath, JSON.stringify(tickets, null, 2));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error saving tickets:'), error);\n    }\n  }\n\n  static async createTicket(\n    guild: Guild,\n    user: User,\n    category: string,\n    answers: string[],\n    panelNumber: number,\n    categoryIndex: number,\n    client?: Client\n  ): Promise<TextChannel | null> {\n    try {\n      const config = ConfigHandler.getConfig();\n      const tickets = this.loadTickets();\n\n      // Check max tickets per user\n      const userTickets = Object.values(tickets).filter(\n        t => t.userId === user.id && (t.status === TicketStatus.OPEN || t.status === TicketStatus.CLAIMED)\n      );\n\n      if (userTickets.length >= config.automation.max_tickets_per_user) {\n        return null; // Max tickets reached\n      }\n\n      const ticketNumber = Object.keys(tickets).length + 1;\n      const ticketId = `ticket-${ticketNumber.toString().padStart(4, '0')}`;\n\n      // Build permission overwrites with validation\n      const permissionOverwrites: any[] = [\n        {\n          id: guild.id,\n          deny: [PermissionFlagsBits.ViewChannel],\n        },\n        {\n          id: user.id,\n          allow: [\n            PermissionFlagsBits.ViewChannel,\n            PermissionFlagsBits.SendMessages,\n            PermissionFlagsBits.ReadMessageHistory,\n            PermissionFlagsBits.AttachFiles,\n          ],\n        },\n      ];\n\n      // Add staff roles only if they exist in the guild\n      for (const roleId of config.staff_roles) {\n        if (roleId && roleId.trim()) {\n          const role = guild.roles.cache.get(roleId);\n          if (role) {\n            permissionOverwrites.push({\n              id: roleId,\n              allow: [\n                PermissionFlagsBits.ViewChannel,\n                PermissionFlagsBits.SendMessages,\n                PermissionFlagsBits.ReadMessageHistory,\n                PermissionFlagsBits.ManageMessages,\n                PermissionFlagsBits.AttachFiles,\n              ],\n            });\n          } else {\n            console.warn(chalk.yellow(`‚ö†Ô∏è Staff role ${roleId} not found in guild, skipping...`));\n          }\n        }\n      }\n\n      const channel = await guild.channels.create({\n        name: `${ticketId}-${user.username}`,\n        type: ChannelType.GuildText,\n        parent: config.ticket_category_id,\n        permissionOverwrites,\n      });\n\n      const ticketData: TicketData = {\n        ticketId,\n        channelId: channel.id,\n        userId: user.id,\n        username: user.username,\n        category,\n        panelNumber,\n        categoryIndex,\n        createdAt: Date.now(),\n        priority: TicketPriority.MEDIUM,\n        tags: [],\n        status: TicketStatus.OPEN,\n        messages: answers.map((answer, index) => ({\n          authorId: user.id,\n          authorUsername: user.username,\n          content: answer,\n          timestamp: Date.now() + index,\n        })),\n        lastActivity: Date.now(),\n      };\n\n      tickets[ticketId] = ticketData;\n      this.saveTickets(tickets);\n\n      // Create welcome embed\n      const embed = new EmbedBuilder()\n        .setTitle(Lang.t('ticket_create.welcome_title'))\n        .setDescription(\n          Lang.t('ticket_create.welcome_description', {\n            ticketId,\n            category,\n            priority: this.getPriorityDisplay(TicketPriority.MEDIUM),\n            timestamp: `<t:${Math.floor(Date.now() / 1000)}:R>`,\n          }) + `\\n\\n**${category}**\\n${answers.map((a, i) => `**Q${i + 1}:** ${a}`).join('\\n\\n')}`\n        )\n        .setColor(config.embed_color)\n        .setFooter({ text: Lang.t('footer.ticket', { ticketId, status: 'Open' }) })\n        .setTimestamp();\n\n      if (config.thumbnail_url) {\n        embed.setThumbnail(config.thumbnail_url);\n      }\n\n      const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(\n        new ButtonBuilder()\n          .setCustomId('ticket_claim')\n          .setLabel('Claim')\n          .setEmoji('‚úã')\n          .setStyle(ButtonStyle.Primary),\n        new ButtonBuilder()\n          .setCustomId('ticket_close')\n          .setLabel('Close')\n          .setEmoji('üîí')\n          .setStyle(ButtonStyle.Danger),\n        new ButtonBuilder()\n          .setCustomId('ticket_priority')\n          .setLabel('Priority')\n          .setEmoji('üéØ')\n          .setStyle(ButtonStyle.Secondary),\n        new ButtonBuilder()\n          .setCustomId('ticket_transcript')\n          .setLabel('Transcript')\n          .setEmoji('üìÑ')\n          .setStyle(ButtonStyle.Secondary)\n      );\n\n      await channel.send({ content: `${user}`, embeds: [embed], components: [buttons] });\n\n      // Log creation\n      Logger.log(\n        LogType.TICKET_CREATED,\n        user.id,\n        user.username,\n        `Created ticket ${ticketId} in category: ${category}`,\n        ticketId\n      );\n\n      if (client) {\n        await Logger.sendToLogChannel(client, {\n          timestamp: Date.now(),\n          type: LogType.TICKET_CREATED,\n          userId: user.id,\n          username: user.username,\n          details: `Created ticket ${ticketId} in category: ${category}`,\n          ticketId,\n        });\n      }\n\n      console.log(chalk.green(`‚úÖ Ticket ${ticketId} created for ${user.tag}`));\n      return channel;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error creating ticket:'), error);\n      return null;\n    }\n  }\n\n  static claimTicket(ticketId: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || ticket.status === TicketStatus.CLOSED) {\n      return false;\n    }\n\n    if (ticket.claimedBy) {\n      return false; // Already claimed\n    }\n\n    ticket.claimedBy = userId;\n    ticket.claimedByUsername = username;\n    ticket.status = TicketStatus.CLAIMED;\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TICKET_CLAIMED,\n      userId,\n      username,\n      `Claimed ticket ${ticketId}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static unclaimTicket(ticketId: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || !ticket.claimedBy) {\n      return false;\n    }\n\n    delete ticket.claimedBy;\n    delete ticket.claimedByUsername;\n    ticket.status = TicketStatus.OPEN;\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TICKET_UNCLAIMED,\n      ticket.userId,\n      ticket.username,\n      `Unclaimed ticket ${ticketId}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static setPriority(ticketId: string, priority: TicketPriority, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket) {\n      return false;\n    }\n\n    ticket.priority = priority;\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.PRIORITY_CHANGED,\n      userId,\n      username,\n      `Changed priority to ${priority}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static addTag(ticketId: string, tag: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || ticket.tags.includes(tag)) {\n      return false;\n    }\n\n    ticket.tags.push(tag);\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TAG_ADDED,\n      userId,\n      username,\n      `Added tag: ${tag}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static removeTag(ticketId: string, tag: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || !ticket.tags.includes(tag)) {\n      return false;\n    }\n\n    ticket.tags = ticket.tags.filter(t => t !== tag);\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TAG_REMOVED,\n      userId,\n      username,\n      `Removed tag: ${tag}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static addMessage(ticketId: string, message: TicketMessage): void {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket) {\n      return;\n    }\n\n    ticket.messages.push(message);\n    ticket.lastActivity = Date.now();\n    ticket.inactivityWarned = false; // Reset warning flag\n    this.saveTickets(tickets);\n  }\n\n  static closeTicket(ticketId: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || ticket.status === TicketStatus.CLOSED) {\n      return false;\n    }\n\n    ticket.status = TicketStatus.CLOSED;\n    ticket.lastActivity = Date.now();\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TICKET_CLOSED,\n      userId,\n      username,\n      `Closed ticket ${ticketId}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static reopenTicket(ticketId: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket || ticket.status !== TicketStatus.CLOSED) {\n      return false;\n    }\n\n    ticket.status = TicketStatus.OPEN;\n    ticket.lastActivity = Date.now();\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TICKET_REOPENED,\n      userId,\n      username,\n      `Reopened ticket ${ticketId}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static deleteTicket(ticketId: string, userId: string, username: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket) {\n      return false;\n    }\n\n    ticket.status = TicketStatus.DELETED;\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.TICKET_DELETED,\n      userId,\n      username,\n      `Deleted ticket ${ticketId}`,\n      ticketId\n    );\n\n    return true;\n  }\n\n  static setRating(ticketId: string, rating: number, feedback?: string): boolean {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (!ticket) {\n      return false;\n    }\n\n    ticket.rating = rating;\n    ticket.feedbackText = feedback;\n    this.saveTickets(tickets);\n\n    Logger.log(\n      LogType.RATING_SUBMITTED,\n      ticket.userId,\n      ticket.username,\n      `Submitted rating: ${rating}/5`,\n      ticketId,\n      { rating, feedback }\n    );\n\n    return true;\n  }\n\n  static getTicketByChannel(channelId: string): { ticketId: string; data: TicketData } | null {\n    const tickets = this.loadTickets();\n    for (const [ticketId, data] of Object.entries(tickets)) {\n      if (data.channelId === channelId && data.status !== TicketStatus.DELETED) {\n        return { ticketId, data };\n      }\n    }\n    return null;\n  }\n\n  static getTicketById(ticketId: string): TicketData | null {\n    const tickets = this.loadTickets();\n    return tickets[ticketId] || null;\n  }\n\n  static getAllTickets(): TicketData[] {\n    const tickets = this.loadTickets();\n    return Object.values(tickets);\n  }\n\n  static getOpenTickets(): TicketData[] {\n    return this.getAllTickets().filter(\n      t => t.status === TicketStatus.OPEN || t.status === TicketStatus.CLAIMED\n    );\n  }\n\n  static getInactiveTickets(minutes: number): TicketData[] {\n    const cutoff = Date.now() - (minutes * 60 * 1000);\n    return this.getOpenTickets().filter(t => t.lastActivity < cutoff);\n  }\n\n  static setInactivityWarned(ticketId: string): void {\n    const tickets = this.loadTickets();\n    const ticket = tickets[ticketId];\n\n    if (ticket) {\n      ticket.inactivityWarned = true;\n      this.saveTickets(tickets);\n    }\n  }\n\n  static getPriorityDisplay(priority: TicketPriority): string {\n    return Lang.t(`priority.${priority}`);\n  }\n\n  static getPriorityColor(priority: TicketPriority): string {\n    const config = ConfigHandler.getConfig();\n    return config.priority_colors[priority];\n  }\n}\n","size_bytes":13081},"src/commands/close.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n  TextChannel,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { TranscriptGenerator } from '../utils/transcriptGenerator.js';\nimport { FeedbackManager } from '../utils/feedbackManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('close')\n  .setDescription('Close the current ticket')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n    if (!ticket) {\n      await interaction.reply({\n        content: '‚ùå This channel is not a ticket.',\n        ephemeral: true,\n      });\n      return;\n    }\n\n    await interaction.reply({\n      content: '‚åõ Closing ticket and generating transcript...',\n      ephemeral: true,\n    });\n\n    const config = ConfigHandler.getConfig();\n    const channel = interaction.channel as TextChannel;\n\n    const transcriptPath = await TranscriptGenerator.generateHTMLTranscript(\n      channel,\n      ticket.ticketId\n    );\n\n    if (transcriptPath) {\n      const transcriptChannel = await interaction.guild?.channels.fetch(\n        config.transcript_channel_id\n      ) as TextChannel;\n\n      if (transcriptChannel) {\n        const embed = new EmbedBuilder()\n          .setTitle(`üìú Ticket Transcript: ${ticket.ticketId}`)\n          .setDescription(\n            `**User:** <@${ticket.data.userId}>\\n**Category:** ${ticket.data.category}\\n**Closed by:** ${interaction.user}\\n**Created:** ${new Date(ticket.data.createdAt).toLocaleString()}`\n          )\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await transcriptChannel.send({\n          embeds: [embed],\n          files: [transcriptPath],\n        });\n      }\n    }\n\n    const user = await interaction.client.users.fetch(ticket.data.userId);\n    await FeedbackManager.sendFeedbackPrompt(user, ticket.ticketId);\n\n    TicketManager.closeTicket(ticket.ticketId);\n\n    const closeEmbed = new EmbedBuilder()\n      .setTitle('üîí Ticket Closed')\n      .setDescription(\n        config.close_ticket_message.replace('{user}', interaction.user.toString())\n      )\n      .setColor(config.embed_color)\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    await channel.send({ embeds: [closeEmbed] });\n\n    setTimeout(async () => {\n      try {\n        await channel.delete();\n        console.log(chalk.green(`‚úÖ Ticket channel ${ticket.ticketId} deleted`));\n      } catch (error) {\n        console.error(chalk.red('‚ùå Error deleting ticket channel:'), error);\n      }\n    }, 5000);\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in close command:'), error);\n    await interaction.followUp({\n      content: '‚ùå An error occurred while closing the ticket.',\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":3098},"src/commands/tag.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { Lang } from '../utils/languageManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('tag')\n  .setDescription('Manage ticket tags')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages)\n  .addSubcommand(subcommand =>\n    subcommand\n      .setName('add')\n      .setDescription('Add a tag to the ticket')\n      .addStringOption(option =>\n        option\n          .setName('tag')\n          .setDescription('Tag to add')\n          .setRequired(true)\n          .setAutocomplete(true)\n      )\n  )\n  .addSubcommand(subcommand =>\n    subcommand\n      .setName('remove')\n      .setDescription('Remove a tag from the ticket')\n      .addStringOption(option =>\n        option\n          .setName('tag')\n          .setDescription('Tag to remove')\n          .setRequired(true)\n          .setAutocomplete(true)\n      )\n  )\n  .addSubcommand(subcommand =>\n    subcommand\n      .setName('list')\n      .setDescription('List all tags on this ticket')\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n    if (!ticket) {\n      await interaction.reply({\n        content: Lang.t('general.invalid_ticket'),\n        ephemeral: true,\n      });\n      return;\n    }\n\n    const subcommand = interaction.options.getSubcommand();\n\n    if (subcommand === 'add') {\n      const tag = interaction.options.getString('tag', true);\n\n      const success = TicketManager.addTag(\n        ticket.ticketId,\n        tag,\n        interaction.user.id,\n        interaction.user.username\n      );\n\n      if (success) {\n        const embed = new EmbedBuilder()\n          .setTitle('üè∑Ô∏è Tag Added')\n          .setDescription(Lang.t('tags.added', { tag }))\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n        console.log(chalk.green(`‚úÖ Tag \"${tag}\" added to ${ticket.ticketId}`));\n      } else {\n        await interaction.reply({\n          content: '‚ùå Tag already exists or could not be added.',\n          ephemeral: true,\n        });\n      }\n    } else if (subcommand === 'remove') {\n      const tag = interaction.options.getString('tag', true);\n\n      const success = TicketManager.removeTag(\n        ticket.ticketId,\n        tag,\n        interaction.user.id,\n        interaction.user.username\n      );\n\n      if (success) {\n        const embed = new EmbedBuilder()\n          .setTitle('üè∑Ô∏è Tag Removed')\n          .setDescription(Lang.t('tags.removed', { tag }))\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n        console.log(chalk.green(`‚úÖ Tag \"${tag}\" removed from ${ticket.ticketId}`));\n      } else {\n        await interaction.reply({\n          content: '‚ùå Tag not found or could not be removed.',\n          ephemeral: true,\n        });\n      }\n    } else if (subcommand === 'list') {\n      const tags = ticket.data.tags;\n\n      const embed = new EmbedBuilder()\n        .setTitle('üè∑Ô∏è Ticket Tags')\n        .setDescription(\n          tags.length > 0\n            ? Lang.t('tags.list', { tags: tags.join(', ') })\n            : Lang.t('tags.none')\n        )\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed], ephemeral: true });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in tag command:'), error);\n    await interaction.reply({\n      content: Lang.t('general.error'),\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":4037},"src/commands/priority.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { Lang } from '../utils/languageManager.js';\nimport { TicketPriority } from '../types/index.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('priority')\n  .setDescription('Set ticket priority level')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages)\n  .addStringOption(option =>\n    option\n      .setName('level')\n      .setDescription('Priority level')\n      .setRequired(true)\n      .addChoices(\n        { name: 'üü¢ Low', value: 'low' },\n        { name: 'üü° Medium', value: 'medium' },\n        { name: 'üü† High', value: 'high' },\n        { name: 'üî¥ Urgent', value: 'urgent' }\n      )\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n    if (!ticket) {\n      await interaction.reply({\n        content: Lang.t('general.invalid_ticket'),\n        ephemeral: true,\n      });\n      return;\n    }\n\n    const level = interaction.options.getString('level', true) as TicketPriority;\n\n    const success = TicketManager.setPriority(\n      ticket.ticketId,\n      level,\n      interaction.user.id,\n      interaction.user.username\n    );\n\n    if (success) {\n      const priorityDisplay = TicketManager.getPriorityDisplay(level);\n      const priorityColor = TicketManager.getPriorityColor(level);\n\n      const embed = new EmbedBuilder()\n        .setTitle('üéØ Priority Updated')\n        .setDescription(Lang.t('priority.set', { priority: priorityDisplay }))\n        .setColor(priorityColor)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed] });\n      console.log(chalk.green(`‚úÖ Ticket ${ticket.ticketId} priority set to ${level}`));\n    } else {\n      await interaction.reply({\n        content: Lang.t('general.error'),\n        ephemeral: true,\n      });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in priority command:'), error);\n    await interaction.reply({\n      content: Lang.t('general.error'),\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":2398},"src/utils/addonManager.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport { Client } from 'discord.js';\nimport chalk from 'chalk';\n\nexport interface Addon {\n  name: string;\n  version: string;\n  description: string;\n  author?: string;\n  onLoad?: (client: Client) => void | Promise<void>;\n  onUnload?: () => void | Promise<void>;\n}\n\nexport class AddonManager {\n  private static addonsDir = path.join(process.cwd(), 'addons');\n  private static loadedAddons: Map<string, Addon> = new Map();\n\n  static {\n    if (!fs.existsSync(this.addonsDir)) {\n      fs.mkdirSync(this.addonsDir, { recursive: true });\n      \n      // Create example addon\n      const exampleAddon = `// Example Addon for Advanced Ticket Bot\n// Place your custom addons in the /addons directory\n\nexport default {\n  name: 'Example Addon',\n  version: '1.0.0',\n  description: 'An example addon showing the structure',\n  author: 'Your Name',\n\n  // Called when addon is loaded\n  async onLoad(client) {\n    console.log('Example addon loaded!');\n    \n    // You can add custom commands, event listeners, etc.\n    // Example: client.on('messageCreate', (message) => { ... });\n  },\n\n  // Called when addon is unloaded\n  async onUnload() {\n    console.log('Example addon unloaded!');\n  }\n};\n`;\n      fs.writeFileSync(\n        path.join(this.addonsDir, 'example-addon.js'),\n        exampleAddon\n      );\n    }\n  }\n\n  static async loadAll(client: Client): Promise<void> {\n    try {\n      const files = fs.readdirSync(this.addonsDir).filter(\n        file => (file.endsWith('.js') || file.endsWith('.ts')) && !file.startsWith('example')\n      );\n\n      console.log(chalk.cyan(`üß© Loading addons from ${this.addonsDir}...`));\n\n      for (const file of files) {\n        await this.load(file, client);\n      }\n\n      console.log(chalk.green(`‚úÖ Loaded ${this.loadedAddons.size} addon(s)`));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading addons:'), error);\n    }\n  }\n\n  static async load(filename: string, client: Client): Promise<boolean> {\n    try {\n      const addonPath = path.join(this.addonsDir, filename);\n      \n      if (!fs.existsSync(addonPath)) {\n        console.error(chalk.red(`‚ùå Addon file not found: ${filename}`));\n        return false;\n      }\n\n      // Import the addon\n      const addonModule = await import(addonPath);\n      const addon: Addon = addonModule.default;\n\n      if (!addon.name || !addon.version) {\n        console.error(chalk.red(`‚ùå Invalid addon structure: ${filename}`));\n        return false;\n      }\n\n      // Call onLoad if it exists\n      if (addon.onLoad) {\n        await addon.onLoad(client);\n      }\n\n      this.loadedAddons.set(addon.name, addon);\n      console.log(chalk.green(`‚úÖ Loaded addon: ${addon.name} v${addon.version}`));\n      return true;\n    } catch (error) {\n      console.error(chalk.red(`‚ùå Error loading addon ${filename}:`), error);\n      return false;\n    }\n  }\n\n  static async unload(addonName: string): Promise<boolean> {\n    try {\n      const addon = this.loadedAddons.get(addonName);\n      \n      if (!addon) {\n        console.error(chalk.red(`‚ùå Addon not found: ${addonName}`));\n        return false;\n      }\n\n      // Call onUnload if it exists\n      if (addon.onUnload) {\n        await addon.onUnload();\n      }\n\n      this.loadedAddons.delete(addonName);\n      console.log(chalk.green(`‚úÖ Unloaded addon: ${addonName}`));\n      return true;\n    } catch (error) {\n      console.error(chalk.red(`‚ùå Error unloading addon ${addonName}:`), error);\n      return false;\n    }\n  }\n\n  static getLoaded(): Addon[] {\n    return Array.from(this.loadedAddons.values());\n  }\n\n  static isLoaded(addonName: string): boolean {\n    return this.loadedAddons.has(addonName);\n  }\n\n  static async reloadAll(client: Client): Promise<void> {\n    console.log(chalk.yellow('üîÑ Reloading all addons...'));\n    \n    // Unload all\n    for (const [name] of this.loadedAddons) {\n      await this.unload(name);\n    }\n\n    // Load all again\n    await this.loadAll(client);\n  }\n}\n","size_bytes":3991},"src/utils/languageManager.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport chalk from 'chalk';\n\ninterface TranslationData {\n  [key: string]: string | TranslationData;\n}\n\nclass LanguageManager {\n  private static instance: LanguageManager;\n  private currentLanguage: string = 'en';\n  private translations: Map<string, TranslationData> = new Map();\n\n  private constructor() {\n    this.loadLanguage('en');\n  }\n\n  public static getInstance(): LanguageManager {\n    if (!LanguageManager.instance) {\n      LanguageManager.instance = new LanguageManager();\n    }\n    return LanguageManager.instance;\n  }\n\n  private loadLanguage(lang: string): void {\n    try {\n      const langPath = path.join(process.cwd(), 'lang', `${lang}.yml`);\n      \n      if (!fs.existsSync(langPath)) {\n        console.log(chalk.yellow(`‚ö†Ô∏è Language file ${lang}.yml not found, using default (en)`));\n        return;\n      }\n\n      const fileContent = fs.readFileSync(langPath, 'utf8');\n      const data = yaml.load(fileContent) as TranslationData;\n      \n      this.translations.set(lang, data);\n      console.log(chalk.green(`‚úÖ Loaded language: ${lang}`));\n    } catch (error) {\n      console.error(chalk.red(`‚ùå Error loading language ${lang}:`), error);\n    }\n  }\n\n  public setLanguage(lang: string): boolean {\n    if (!this.translations.has(lang)) {\n      this.loadLanguage(lang);\n    }\n\n    if (this.translations.has(lang)) {\n      this.currentLanguage = lang;\n      return true;\n    }\n\n    return false;\n  }\n\n  public getCurrentLanguage(): string {\n    return this.currentLanguage;\n  }\n\n  public translate(key: string, replacements?: { [key: string]: string }): string {\n    const keys = key.split('.');\n    let value: any = this.translations.get(this.currentLanguage);\n\n    if (!value) {\n      return key;\n    }\n\n    for (const k of keys) {\n      value = value[k];\n      if (value === undefined) {\n        console.log(chalk.yellow(`‚ö†Ô∏è Translation key not found: ${key}`));\n        return key;\n      }\n    }\n\n    let result = String(value);\n\n    if (replacements) {\n      Object.entries(replacements).forEach(([placeholder, replacement]) => {\n        result = result.replace(new RegExp(`\\\\{${placeholder}\\\\}`, 'g'), replacement);\n      });\n    }\n\n    return result;\n  }\n\n  public t(key: string, replacements?: { [key: string]: string }): string {\n    return this.translate(key, replacements);\n  }\n\n  public getAvailableLanguages(): string[] {\n    const langDir = path.join(process.cwd(), 'lang');\n    \n    if (!fs.existsSync(langDir)) {\n      return ['en'];\n    }\n\n    return fs\n      .readdirSync(langDir)\n      .filter(file => file.endsWith('.yml'))\n      .map(file => file.replace('.yml', ''));\n  }\n}\n\nexport const Lang = LanguageManager.getInstance();\n","size_bytes":2760},"src/utils/blacklistManager.ts":{"content":"import * as fs from 'fs';\nimport { User } from 'discord.js';\nimport chalk from 'chalk';\n\ninterface BlacklistEntry {\n  userId: string;\n  userName: string;\n  reason: string;\n  timestamp: string;\n}\n\ninterface BlacklistDatabase {\n  [userId: string]: BlacklistEntry;\n}\n\nexport class BlacklistManager {\n  private static blacklistPath = 'data/blacklist.json';\n\n  private static loadBlacklist(): BlacklistDatabase {\n    try {\n      if (!fs.existsSync(this.blacklistPath)) {\n        fs.writeFileSync(this.blacklistPath, '{}');\n      }\n      const data = fs.readFileSync(this.blacklistPath, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading blacklist:'), error);\n      return {};\n    }\n  }\n\n  private static saveBlacklist(blacklist: BlacklistDatabase): void {\n    try {\n      fs.writeFileSync(this.blacklistPath, JSON.stringify(blacklist, null, 2));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error saving blacklist:'), error);\n    }\n  }\n\n  static addUser(user: User, reason: string = 'No reason provided'): void {\n    const blacklist = this.loadBlacklist();\n    \n    blacklist[user.id] = {\n      userId: user.id,\n      userName: user.tag,\n      reason,\n      timestamp: new Date().toISOString(),\n    };\n\n    this.saveBlacklist(blacklist);\n    console.log(chalk.green(`‚úÖ User ${user.tag} added to blacklist`));\n  }\n\n  static removeUser(userId: string): boolean {\n    const blacklist = this.loadBlacklist();\n    \n    if (blacklist[userId]) {\n      delete blacklist[userId];\n      this.saveBlacklist(blacklist);\n      console.log(chalk.green(`‚úÖ User removed from blacklist`));\n      return true;\n    }\n    \n    return false;\n  }\n\n  static isBlacklisted(userId: string): boolean {\n    const blacklist = this.loadBlacklist();\n    return userId in blacklist;\n  }\n\n  static getBlacklist(): BlacklistDatabase {\n    return this.loadBlacklist();\n  }\n\n  static getEntry(userId: string): BlacklistEntry | null {\n    const blacklist = this.loadBlacklist();\n    return blacklist[userId] || null;\n  }\n}\n","size_bytes":2058},"src/utils/statsManager.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport { StatsData, TicketData, TicketStatus } from '../types/index.js';\nimport { TicketManager } from './ticketManager.js';\n\nexport class StatsManager {\n  private static dataFile = path.join(process.cwd(), 'data', 'stats.json');\n\n  public static calculateStats(): StatsData {\n    const allTickets = TicketManager.getAllTickets();\n    const openTickets = allTickets.filter(t => t.status === TicketStatus.OPEN || t.status === TicketStatus.CLAIMED);\n    const closedTickets = allTickets.filter(t => t.status === TicketStatus.CLOSED);\n\n    const stats: StatsData = {\n      totalTickets: allTickets.length,\n      openTickets: openTickets.length,\n      closedTickets: closedTickets.length,\n      avgResponseTime: this.calculateAvgResponseTime(closedTickets),\n      avgResolutionTime: this.calculateAvgResolutionTime(closedTickets),\n      avgRating: this.calculateAvgRating(closedTickets),\n      ticketsByCategory: this.getTicketsByCategory(allTickets),\n      ticketsByStaff: this.getTicketsByStaff(allTickets),\n      ratingDistribution: this.getRatingDistribution(closedTickets),\n    };\n\n    this.saveStats(stats);\n    return stats;\n  }\n\n  private static calculateAvgResponseTime(tickets: TicketData[]): number {\n    if (tickets.length === 0) return 0;\n\n    let totalResponseTime = 0;\n    let count = 0;\n\n    for (const ticket of tickets) {\n      if (ticket.messages.length >= 2) {\n        const firstUserMessage = ticket.messages[0];\n        const firstStaffMessage = ticket.messages.find(m => m.authorId !== ticket.userId);\n        \n        if (firstStaffMessage) {\n          totalResponseTime += firstStaffMessage.timestamp - firstUserMessage.timestamp;\n          count++;\n        }\n      }\n    }\n\n    return count > 0 ? Math.floor(totalResponseTime / count / 1000 / 60) : 0; // Return in minutes\n  }\n\n  private static calculateAvgResolutionTime(tickets: TicketData[]): number {\n    if (tickets.length === 0) return 0;\n\n    let totalTime = 0;\n    let count = 0;\n\n    for (const ticket of tickets) {\n      if (ticket.status === TicketStatus.CLOSED && ticket.createdAt) {\n        const closedTime = ticket.lastActivity || Date.now();\n        totalTime += closedTime - ticket.createdAt;\n        count++;\n      }\n    }\n\n    return count > 0 ? Math.floor(totalTime / count / 1000 / 60 / 60) : 0; // Return in hours\n  }\n\n  private static calculateAvgRating(tickets: TicketData[]): number {\n    const ratedTickets = tickets.filter(t => t.rating !== undefined);\n    if (ratedTickets.length === 0) return 0;\n\n    const totalRating = ratedTickets.reduce((sum, t) => sum + (t.rating || 0), 0);\n    return Math.round((totalRating / ratedTickets.length) * 10) / 10;\n  }\n\n  private static getTicketsByCategory(tickets: TicketData[]): { [key: string]: number } {\n    const categories: { [key: string]: number } = {};\n\n    for (const ticket of tickets) {\n      categories[ticket.category] = (categories[ticket.category] || 0) + 1;\n    }\n\n    return categories;\n  }\n\n  private static getTicketsByStaff(tickets: TicketData[]): { [key: string]: number } {\n    const staff: { [key: string]: number } = {};\n\n    for (const ticket of tickets) {\n      if (ticket.claimedByUsername) {\n        staff[ticket.claimedByUsername] = (staff[ticket.claimedByUsername] || 0) + 1;\n      }\n    }\n\n    return staff;\n  }\n\n  private static getRatingDistribution(tickets: TicketData[]): { [key: number]: number } {\n    const distribution: { [key: number]: number } = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n\n    for (const ticket of tickets) {\n      if (ticket.rating) {\n        distribution[ticket.rating]++;\n      }\n    }\n\n    return distribution;\n  }\n\n  public static getTopStaff(): { username: string; count: number } | null {\n    const stats = this.calculateStats();\n    const staffEntries = Object.entries(stats.ticketsByStaff);\n\n    if (staffEntries.length === 0) return null;\n\n    const [username, count] = staffEntries.reduce((max, current) => \n      current[1] > max[1] ? current : max\n    );\n\n    return { username, count };\n  }\n\n  public static getBusiestCategory(): { category: string; count: number } | null {\n    const stats = this.calculateStats();\n    const categoryEntries = Object.entries(stats.ticketsByCategory);\n\n    if (categoryEntries.length === 0) return null;\n\n    const [category, count] = categoryEntries.reduce((max, current) => \n      current[1] > max[1] ? current : max\n    );\n\n    return { category, count };\n  }\n\n  private static saveStats(stats: StatsData): void {\n    try {\n      fs.writeFileSync(this.dataFile, JSON.stringify(stats, null, 2));\n    } catch (error) {\n      console.error('Error saving stats:', error);\n    }\n  }\n\n  public static loadStats(): StatsData | null {\n    try {\n      if (fs.existsSync(this.dataFile)) {\n        const data = fs.readFileSync(this.dataFile, 'utf8');\n        return JSON.parse(data);\n      }\n    } catch (error) {\n      console.error('Error loading stats:', error);\n    }\n    return null;\n  }\n}\n","size_bytes":4978},"src/events/ready.ts":{"content":"import { Client, REST, Routes } from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport chalk from 'chalk';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport async function execute(client: Client) {\n  console.log(chalk.blue('\\n========================================'));\n  console.log(chalk.blue('  üé´ Discord Ticket Bot'));\n  console.log(chalk.blue('========================================\\n'));\n\n  console.log(chalk.green(`‚úÖ Logged in as ${client.user?.tag}`));\n  console.log(chalk.cyan(`üìä Serving ${client.guilds.cache.size} guild(s)`));\n\n  try {\n    const config = ConfigHandler.getConfig();\n    \n    console.log(chalk.yellow('\\n‚åõ Deploying slash commands...'));\n    \n    const commands = [];\n    const commandsPath = path.join(process.cwd(), 'src', 'commands');\n    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.ts'));\n\n    for (const file of commandFiles) {\n      const filePath = path.join(commandsPath, file);\n      const command = await import(filePath);\n      if (command.data) {\n        commands.push(command.data.toJSON());\n      }\n    }\n\n    const rest = new REST({ version: '10' }).setToken(config.token);\n\n    await rest.put(\n      Routes.applicationGuildCommands(client.user!.id, config.guild_id),\n      { body: commands }\n    );\n\n    console.log(chalk.green(`‚úÖ Successfully deployed ${commands.length} slash command(s)`));\n    \n    console.log(chalk.blue('\\n========================================'));\n    console.log(chalk.green('  ‚úÖ Bot is ready!'));\n    console.log(chalk.blue('========================================\\n'));\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in ready event:'), error);\n  }\n}\n","size_bytes":1731},"src/utils/configHandler.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport chalk from 'chalk';\nimport { Config, Panels } from '../types/index.js';\nimport { EnvLoader } from './envLoader.js';\n\nexport class ConfigHandler {\n  private static config: Config | null = null;\n  private static panels: Panels | null = null;\n  private static configPath = path.join(process.cwd(), 'config.yml');\n  private static panelsPath = path.join(process.cwd(), 'ticket-panels.yml');\n\n  static loadConfig(): Config {\n    try {\n      // Load environment variables first\n      EnvLoader.load();\n\n      if (!fs.existsSync(this.configPath)) {\n        console.log(chalk.yellow('‚ö†Ô∏è config.yml not found, creating default...'));\n        this.createDefaultConfig();\n      }\n\n      const fileContent = fs.readFileSync(this.configPath, 'utf8');\n      const yamlConfig = yaml.load(fileContent) as any;\n\n      // Merge environment variables with YAML config\n      this.config = this.mergeWithEnv(yamlConfig);\n      \n      // Validate required fields\n      this.validateConfig(this.config);\n\n      console.log(chalk.green('‚úÖ Config loaded successfully'));\n      return this.config;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading config.yml:'), error);\n      throw error;\n    }\n  }\n\n  private static mergeWithEnv(yamlConfig: any): Config {\n    // Environment variables take precedence over config.yml\n    return {\n      // Core Discord settings\n      token: EnvLoader.get('DISCORD_TOKEN') || yamlConfig.token || '',\n      guild_id: EnvLoader.get('GUILD_ID') || yamlConfig.guild_id || '',\n      \n      // Staff and channels\n      staff_roles: EnvLoader.getArray('STAFF_ROLES').length > 0 \n        ? EnvLoader.getArray('STAFF_ROLES') \n        : (yamlConfig.staff_roles || []),\n      ticket_category_id: EnvLoader.get('TICKET_CATEGORY_ID') || yamlConfig.ticket_category_id || '',\n      feedback_channel_id: EnvLoader.get('FEEDBACK_CHANNEL_ID') || yamlConfig.feedback_channel_id || '',\n      transcript_channel_id: EnvLoader.get('TRANSCRIPT_CHANNEL_ID') || yamlConfig.transcript_channel_id || '',\n      log_channel_id: EnvLoader.get('LOG_CHANNEL_ID') || yamlConfig.log_channel_id,\n      \n      // Branding\n      bot_name: EnvLoader.get('BOT_NAME') || yamlConfig.bot_name || 'Support Bot',\n      embed_color: EnvLoader.get('EMBED_COLOR') || yamlConfig.embed_color || '#5865F2',\n      footer_text: EnvLoader.get('FOOTER_TEXT') || yamlConfig.footer_text || 'Support System ¬© 2025',\n      thumbnail_url: yamlConfig.thumbnail_url,\n      banner_url: yamlConfig.banner_url,\n      \n      // Language\n      language: EnvLoader.get('LANGUAGE') || yamlConfig.language || 'en',\n      \n      // Features\n      features: {\n        ai_responses: EnvLoader.getBoolean('ENABLE_AI_RESPONSES', yamlConfig.features?.ai_responses),\n        auto_close: EnvLoader.getBoolean('ENABLE_AUTO_CLOSE', yamlConfig.features?.auto_close),\n        working_hours: EnvLoader.getBoolean('ENABLE_WORKING_HOURS', yamlConfig.features?.working_hours),\n        ticket_reviews: EnvLoader.getBoolean('ENABLE_TICKET_REVIEWS', yamlConfig.features?.ticket_reviews),\n        transcripts: EnvLoader.getBoolean('ENABLE_TRANSCRIPTS', yamlConfig.features?.transcripts),\n        addons: EnvLoader.getBoolean('ENABLE_ADDONS', yamlConfig.features?.addons),\n      },\n      \n      // Automation\n      automation: {\n        inactivity_timeout: EnvLoader.getNumber('INACTIVITY_TIMEOUT', yamlConfig.automation?.inactivity_timeout || 2880),\n        inactivity_warning: EnvLoader.getNumber('INACTIVITY_WARNING', yamlConfig.automation?.inactivity_warning || 1440),\n        staff_reminder_timeout: EnvLoader.getNumber('STAFF_REMINDER_TIMEOUT', yamlConfig.automation?.staff_reminder_timeout || 60),\n        max_tickets_per_user: EnvLoader.getNumber('MAX_TICKETS_PER_USER', yamlConfig.automation?.max_tickets_per_user || 3),\n        ticket_overload_limit: EnvLoader.getNumber('TICKET_OVERLOAD_LIMIT', yamlConfig.automation?.ticket_overload_limit || 50),\n      },\n      \n      // Working hours\n      working_hours: yamlConfig.working_hours || {\n        enabled: false,\n        timezone: 'America/New_York',\n        schedule: {},\n      },\n      \n      // Transcripts\n      transcripts: {\n        format: (EnvLoader.get('TRANSCRIPT_FORMAT') || yamlConfig.transcripts?.format || 'html') as 'html' | 'txt' | 'both',\n        send_to_user: yamlConfig.transcripts?.send_to_user !== false,\n        send_to_staff_log: yamlConfig.transcripts?.send_to_staff_log !== false,\n        include_attachments: yamlConfig.transcripts?.include_attachments !== false,\n      },\n      \n      // AI\n      ai: {\n        enabled: yamlConfig.ai?.enabled || false,\n        provider: EnvLoader.get('AI_PROVIDER') || yamlConfig.ai?.provider,\n        api_key: EnvLoader.get('AI_API_KEY') || yamlConfig.ai?.api_key,\n        model: EnvLoader.get('AI_MODEL') || yamlConfig.ai?.model,\n        auto_respond_delay: yamlConfig.ai?.auto_respond_delay || 5,\n      },\n      \n      // Priority colors\n      priority_colors: yamlConfig.priority_colors || {\n        low: '#00ff00',\n        medium: '#ffff00',\n        high: '#ff8800',\n        urgent: '#ff0000',\n      },\n      \n      // Tags\n      available_tags: yamlConfig.available_tags || ['Billing', 'Technical', 'Bug Report', 'Feature Request', 'Refund', 'Other'],\n    };\n  }\n\n  private static validateConfig(config: Config): void {\n    const errors: string[] = [];\n\n    if (!config.token) {\n      errors.push('Discord bot token is required (set DISCORD_TOKEN in .env or token in config.yml)');\n    }\n\n    if (!config.guild_id) {\n      errors.push('Guild ID is required (set GUILD_ID in .env or guild_id in config.yml)');\n    }\n\n    if (!config.ticket_category_id) {\n      errors.push('Ticket category ID is required');\n    }\n\n    if (errors.length > 0) {\n      console.error(chalk.red('\\n‚ùå Configuration errors:'));\n      errors.forEach(err => console.error(chalk.red(`   - ${err}`)));\n      console.error(chalk.yellow('\\nüí° Tip: Copy .env.example to .env and configure your settings\\n'));\n      throw new Error('Invalid configuration');\n    }\n  }\n\n  static loadPanels(): Panels {\n    try {\n      if (!fs.existsSync(this.panelsPath)) {\n        console.log(chalk.yellow('‚ö†Ô∏è ticket-panels.yml not found, creating default...'));\n        this.createDefaultPanels();\n      }\n\n      const fileContent = fs.readFileSync(this.panelsPath, 'utf8');\n      this.panels = yaml.load(fileContent) as Panels;\n      console.log(chalk.green('‚úÖ Ticket panels loaded successfully'));\n      return this.panels;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading ticket-panels.yml:'), error);\n      throw error;\n    }\n  }\n\n  static getConfig(): Config {\n    if (!this.config) {\n      return this.loadConfig();\n    }\n    return this.config;\n  }\n\n  static getPanels(): Panels {\n    if (!this.panels) {\n      return this.loadPanels();\n    }\n    return this.panels;\n  }\n\n  static reload(): void {\n    console.log(chalk.yellow('üîÑ Reloading configuration...'));\n    this.config = null;\n    this.panels = null;\n    this.loadConfig();\n    this.loadPanels();\n    console.log(chalk.green('‚úÖ Configuration reloaded successfully'));\n  }\n\n  static updateConfig(updates: Partial<Config>): void {\n    try {\n      const config = this.getConfig();\n      Object.assign(config, updates);\n      \n      const yamlStr = yaml.dump(config, { indent: 2 });\n      fs.writeFileSync(this.configPath, yamlStr);\n      \n      this.config = config;\n      console.log(chalk.green('‚úÖ Config updated successfully'));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error updating config:'), error);\n    }\n  }\n\n  private static createDefaultConfig(): void {\n    const defaultConfig: Partial<Config> = {\n      token: '',\n      guild_id: '',\n      staff_roles: [],\n      ticket_category_id: '',\n      feedback_channel_id: '',\n      transcript_channel_id: '',\n      log_channel_id: '',\n      bot_name: 'Support Bot',\n      embed_color: '#5865F2',\n      footer_text: 'Support System ¬© 2025',\n      language: 'en',\n      features: {\n        ai_responses: false,\n        auto_close: true,\n        working_hours: false,\n        ticket_reviews: true,\n        transcripts: true,\n        addons: true,\n      },\n      automation: {\n        inactivity_timeout: 2880,\n        inactivity_warning: 1440,\n        staff_reminder_timeout: 60,\n        max_tickets_per_user: 3,\n        ticket_overload_limit: 50,\n      },\n      priority_colors: {\n        low: '#00ff00',\n        medium: '#ffff00',\n        high: '#ff8800',\n        urgent: '#ff0000',\n      },\n      available_tags: ['Billing', 'Technical', 'Bug Report', 'Feature Request', 'Refund', 'Other'],\n    };\n\n    const yamlStr = yaml.dump(defaultConfig, { indent: 2 });\n    fs.writeFileSync(this.configPath, yamlStr);\n  }\n\n  private static createDefaultPanels(): void {\n    // Default panels will be kept as is\n  }\n}\n","size_bytes":8901},"src/commands/claim.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { Lang } from '../utils/languageManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('claim')\n  .setDescription('Claim or unclaim a ticket')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages)\n  .addSubcommand(subcommand =>\n    subcommand\n      .setName('ticket')\n      .setDescription('Claim the current ticket')\n  )\n  .addSubcommand(subcommand =>\n    subcommand\n      .setName('unclaim')\n      .setDescription('Unclaim the current ticket')\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n    if (!ticket) {\n      await interaction.reply({\n        content: Lang.t('general.invalid_ticket'),\n        ephemeral: true,\n      });\n      return;\n    }\n\n    const subcommand = interaction.options.getSubcommand();\n\n    if (subcommand === 'ticket') {\n      if (ticket.data.claimedBy) {\n        await interaction.reply({\n          content: Lang.t('ticket_manage.already_claimed', {\n            user: `<@${ticket.data.claimedBy}>`,\n          }),\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const success = TicketManager.claimTicket(\n        ticket.ticketId,\n        interaction.user.id,\n        interaction.user.username\n      );\n\n      if (success) {\n        const embed = new EmbedBuilder()\n          .setTitle('‚úã Ticket Claimed')\n          .setDescription(\n            Lang.t('ticket_manage.claimed', { user: interaction.user.toString() })\n          )\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n        console.log(chalk.green(`‚úÖ Ticket ${ticket.ticketId} claimed by ${interaction.user.tag}`));\n      } else {\n        await interaction.reply({\n          content: Lang.t('general.error'),\n          ephemeral: true,\n        });\n      }\n    } else if (subcommand === 'unclaim') {\n      if (!ticket.data.claimedBy) {\n        await interaction.reply({\n          content: '‚ùå This ticket is not claimed.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const success = TicketManager.unclaimTicket(ticket.ticketId);\n\n      if (success) {\n        const embed = new EmbedBuilder()\n          .setTitle('üëã Ticket Unclaimed')\n          .setDescription(Lang.t('ticket_manage.unclaimed'))\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n        console.log(chalk.green(`‚úÖ Ticket ${ticket.ticketId} unclaimed`));\n      } else {\n        await interaction.reply({\n          content: Lang.t('general.error'),\n          ephemeral: true,\n        });\n      }\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in claim command:'), error);\n    await interaction.reply({\n      content: Lang.t('general.error'),\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":3319},"src/utils/automationManager.ts":{"content":"import { Client, TextChannel, EmbedBuilder } from 'discord.js';\nimport { TicketManager } from './ticketManager.js';\nimport { ConfigHandler } from './configHandler.js';\nimport { Lang } from './languageManager.js';\nimport { Logger } from './logger.js';\nimport { LogType } from '../types/index.js';\nimport chalk from 'chalk';\n\nexport class AutomationManager {\n  private static checkInterval: NodeJS.Timeout | null = null;\n\n  static startMonitoring(client: Client): void {\n    if (this.checkInterval) {\n      return; // Already running\n    }\n\n    // Check every 5 minutes\n    this.checkInterval = setInterval(() => {\n      this.checkInactivity(client);\n      this.checkStaffResponse(client);\n    }, 5 * 60 * 1000);\n\n    console.log(chalk.green('‚úÖ Automation monitoring started'));\n  }\n\n  static stopMonitoring(): void {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n      console.log(chalk.yellow('‚ö†Ô∏è Automation monitoring stopped'));\n    }\n  }\n\n  private static async checkInactivity(client: Client): Promise<void> {\n    try {\n      const config = ConfigHandler.getConfig();\n      \n      if (!config.features.auto_close) {\n        return;\n      }\n\n      const warningMinutes = config.automation.inactivity_warning;\n      const closeMinutes = config.automation.inactivity_timeout;\n\n      // Get tickets that need warnings\n      const ticketsToWarn = TicketManager.getInactiveTickets(warningMinutes).filter(\n        t => !t.inactivityWarned\n      );\n\n      for (const ticket of ticketsToWarn) {\n        try {\n          const channel = await client.channels.fetch(ticket.channelId) as TextChannel;\n          if (!channel) continue;\n\n          const timeRemaining = closeMinutes - warningMinutes;\n          \n          const embed = new EmbedBuilder()\n            .setTitle('‚ö†Ô∏è Inactivity Warning')\n            .setDescription(\n              Lang.t('automation.inactivity_warning', {\n                time: `${timeRemaining} minutes`,\n              })\n            )\n            .setColor('#FFA500')\n            .setTimestamp();\n\n          await channel.send({ embeds: [embed] });\n          TicketManager.setInactivityWarned(ticket.ticketId);\n          \n          console.log(chalk.yellow(`‚ö†Ô∏è Inactivity warning sent for ${ticket.ticketId}`));\n        } catch (error) {\n          console.error(chalk.red(`‚ùå Error sending warning for ${ticket.ticketId}:`), error);\n        }\n      }\n\n      // Get tickets to auto-close\n      const ticketsToClose = TicketManager.getInactiveTickets(closeMinutes).filter(\n        t => t.inactivityWarned\n      );\n\n      for (const ticket of ticketsToClose) {\n        try {\n          const channel = await client.channels.fetch(ticket.channelId) as TextChannel;\n          if (!channel) continue;\n\n          const embed = new EmbedBuilder()\n            .setTitle('üîí Ticket Auto-Closed')\n            .setDescription(Lang.t('automation.auto_closed'))\n            .setColor('#FF0000')\n            .setTimestamp();\n\n          await channel.send({ embeds: [embed] });\n          \n          TicketManager.closeTicket(ticket.ticketId, client.user!.id, client.user!.username);\n          \n          console.log(chalk.red(`üîí Auto-closed ticket ${ticket.ticketId} due to inactivity`));\n        } catch (error) {\n          console.error(chalk.red(`‚ùå Error auto-closing ${ticket.ticketId}:`), error);\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error in inactivity check:'), error);\n    }\n  }\n\n  private static async checkStaffResponse(client: Client): Promise<void> {\n    try {\n      const config = ConfigHandler.getConfig();\n      const reminderMinutes = config.automation.staff_reminder_timeout;\n\n      const unrespondedTickets = TicketManager.getInactiveTickets(reminderMinutes).filter(\n        t => t.messages.length === 1 && t.messages[0].authorId === t.userId\n      );\n\n      for (const ticket of unrespondedTickets) {\n        try {\n          const channel = await client.channels.fetch(ticket.channelId) as TextChannel;\n          if (!channel) continue;\n\n          const timeWaiting = Math.floor((Date.now() - ticket.lastActivity) / 1000 / 60);\n          \n          const embed = new EmbedBuilder()\n            .setTitle('üì¢ Staff Reminder')\n            .setDescription(\n              Lang.t('automation.staff_reminder', {\n                ticketId: ticket.ticketId,\n                time: `${timeWaiting} minutes`,\n              })\n            )\n            .setColor('#FFA500')\n            .setTimestamp();\n\n          // Ping staff roles\n          const staffPings = config.staff_roles.map(id => `<@&${id}>`).join(' ');\n          await channel.send({ content: staffPings, embeds: [embed] });\n          \n          console.log(chalk.yellow(`üì¢ Staff reminder sent for ${ticket.ticketId}`));\n        } catch (error) {\n          console.error(chalk.red(`‚ùå Error sending staff reminder for ${ticket.ticketId}:`), error);\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error in staff response check:'), error);\n    }\n  }\n\n  static checkWorkingHours(): { isOpen: boolean; message?: string } {\n    const config = ConfigHandler.getConfig();\n    \n    if (!config.working_hours?.enabled) {\n      return { isOpen: true };\n    }\n\n    const now = new Date();\n    const dayName = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase() as keyof typeof config.working_hours.schedule;\n    const daySchedule = config.working_hours.schedule[dayName];\n\n    if (!daySchedule?.enabled) {\n      const hours = this.getWorkingHoursString(config);\n      return {\n        isOpen: false,\n        message: Lang.t('working_hours.outside', { hours }),\n      };\n    }\n\n    const currentTime = now.toLocaleTimeString('en-US', {\n      hour12: false,\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n\n    if (currentTime < daySchedule.start || currentTime > daySchedule.end) {\n      const hours = this.getWorkingHoursString(config);\n      return {\n        isOpen: false,\n        message: Lang.t('working_hours.outside', { hours }),\n      };\n    }\n\n    return { isOpen: true };\n  }\n\n  private static getWorkingHoursString(config: any): string {\n    const schedule = config.working_hours.schedule;\n    const days = Object.entries(schedule)\n      .filter(([_, data]: [string, any]) => data.enabled)\n      .map(([day, data]: [string, any]) => `${day}: ${data.start}-${data.end}`);\n    \n    return days.join(', ');\n  }\n\n  static checkTicketOverload(): boolean {\n    const config = ConfigHandler.getConfig();\n    const openTickets = TicketManager.getOpenTickets();\n    \n    return openTickets.length >= config.automation.ticket_overload_limit;\n  }\n}\n","size_bytes":6686},"src/commands/feedback.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { FeedbackManager } from '../utils/feedbackManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('feedback')\n  .setDescription('View all feedback received')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const allFeedback = FeedbackManager.getAllFeedback();\n\n    if (allFeedback.length === 0) {\n      await interaction.reply({\n        content: 'üìä No feedback has been received yet.',\n        ephemeral: true,\n      });\n      return;\n    }\n\n    const recentFeedback = allFeedback.slice(-10).reverse();\n\n    const avgRating =\n      allFeedback.reduce((sum, f) => sum + f.rating, 0) / allFeedback.length;\n\n    const embed = new EmbedBuilder()\n      .setTitle('üìä Support Feedback Summary')\n      .setDescription(\n        `**Total Feedback:** ${allFeedback.length}\\n` +\n          `**Average Rating:** ${'‚≠ê'.repeat(Math.round(avgRating))} (${avgRating.toFixed(1)}/5)\\n\\n` +\n          `**Recent Feedback (Last 10):**\\n\\n` +\n          recentFeedback\n            .map(\n              (f) =>\n                `**${f.ticketId}** - <@${f.userId}>\\n` +\n                `${'‚≠ê'.repeat(f.rating)} (${f.rating}/5) - ${new Date(f.timestamp).toLocaleDateString()}`\n            )\n            .join('\\n\\n')\n      )\n      .setColor(config.embed_color)\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    await interaction.reply({ embeds: [embed], ephemeral: true });\n    console.log(chalk.green(`‚úÖ Feedback viewed by ${interaction.user.tag}`));\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in feedback command:'), error);\n    await interaction.reply({\n      content: '‚ùå An error occurred while fetching feedback.',\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":2066},"README.md":{"content":"# üé´ Advanced Discord Ticket Bot\n\nA modern, production-ready Discord ticket support system with comprehensive features including multi-language support, automation, analytics, AI responses, and full customization.\n\n[![Discord.js](https://img.shields.io/badge/discord.js-v14.15.3-blue.svg)](https://discord.js.org/)\n[![TypeScript](https://img.shields.io/badge/TypeScript-5.9.3-blue.svg)](https://www.typescriptlang.org/)\n[![License](https://img.shields.io/badge/license-ISC-green.svg)](LICENSE)\n\n## ‚ú® Features\n\n### Core Ticket Management\n- ‚úÖ **Fully Customizable Panels** - YAML-based configuration for unlimited ticket categories\n- ‚úÖ **Custom Modal Forms** - Configurable questions per category\n- ‚úÖ **Priority System** - Low, Medium, High, Urgent with color coding\n- ‚úÖ **Ticket Claiming** - Staff can claim tickets for ownership tracking\n- ‚úÖ **Advanced Tagging** - Custom tags for better categorization\n- ‚úÖ **Member Management** - Add/remove users from tickets\n\n### Automation & Intelligence\n- ‚úÖ **Auto-Close System** - Automatic closure after configurable inactivity period\n- ‚úÖ **Inactivity Warnings** - Warns users before auto-closing\n- ‚úÖ **Staff Reminders** - Notifies staff of unanswered tickets\n- ‚úÖ **Working Hours** - Configurable support hours with timezone support\n- ‚úÖ **Ticket Overload Detection** - Alerts when support volume is high\n- ‚úÖ **AI Auto-Responses** - Optional AI-powered ticket responses (OpenAI, etc.)\n\n### Analytics & Reporting\n- üìä **Comprehensive Statistics** - Total tickets, response times, ratings, and more\n- üìà **Staff Performance Tracking** - Monitor individual staff activity\n- üìã **Detailed Logging** - All ticket actions logged with timestamps\n- ‚≠ê **Customer Feedback System** - 1-5 star ratings with optional comments\n- üìÑ **Transcript Generation** - Beautiful HTML or TXT transcripts\n\n### Customization & Branding\n- üé® **Full Embed Customization** - Colors, footers, thumbnails, banners\n- üåç **Multi-Language Support** - Easy translation system (English included)\n- üè∑Ô∏è **Custom Tags** - Define your own categorization tags\n- üéØ **Priority Colors** - Customizable colors for each priority level\n- üíº **Brand Identity** - Set bot name, footer text, and visual elements\n\n### Developer-Friendly\n- üß© **Addon System** - Load custom JavaScript/TypeScript modules dynamically\n- üîß **Modular Architecture** - Clean, organized codebase\n- üì¶ **Docker Support** - Ready-to-deploy containerized setup\n- üîê **Environment Variables** - Secure configuration management\n- üìù **TypeScript** - Fully typed for better development experience\n\n---\n\n## üöÄ Quick Start\n\n### Prerequisites\n- Node.js 20+ or Docker\n- Discord Bot Token ([Get one here](https://discord.com/developers/applications))\n- Server with appropriate permissions\n\n### Installation\n\n#### Option 1: Standard Installation\n\n```bash\n# Clone the repository\ngit clone <repository-url>\ncd discord-ticket-bot\n\n# Install dependencies\nnpm install\n\n# Copy environment file\ncp .env.example .env\n\n# Edit configuration\nnano config.yml\n\n# Start the bot\nnpm start\n```\n\n#### Option 2: Docker Installation\n\n```bash\n# Copy environment file\ncp .env.example .env\n\n# Edit docker-compose.yml and .env with your settings\n\n# Start with Docker Compose\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f\n```\n\n---\n\n## ‚öôÔ∏è Configuration\n\n### 1. Bot Setup\n\nEdit `config.yml`:\n\n```yaml\n# Discord Settings\ntoken: \"YOUR_BOT_TOKEN\"\nguild_id: \"YOUR_SERVER_ID\"\nstaff_roles:\n  - \"STAFF_ROLE_ID\"\n\n# Channel IDs\nticket_category_id: \"CATEGORY_ID\"\nfeedback_channel_id: \"CHANNEL_ID\"\ntranscript_channel_id: \"CHANNEL_ID\"\nlog_channel_id: \"CHANNEL_ID\"\n\n# Branding\nbot_name: \"Your Support Bot\"\nembed_color: \"#5865F2\"\nfooter_text: \"Your Footer Text\"\n```\n\n### 2. Ticket Panels\n\nEdit `ticket-panels.yml` to create custom ticket categories:\n\n```yaml\npanels:\n  1:\n    title: \"üéüÔ∏è Support Tickets\"\n    description: \"Choose your issue below\"\n    color: \"#5865F2\"\n    footer: \"Support Center\"\n    emoji: \"üé´\"\n    categories:\n      - label: \"üí¨ General Support\"\n        description: \"Ask general questions\"\n        emoji: \"üí¨\"\n        modal:\n          title: \"Open Support Ticket\"\n          questions:\n            - label: \"Describe your issue\"\n              style: \"paragraph\"\n              required: true\n```\n\n---\n\n## üìã Commands\n\n### Admin Commands\n| Command | Description | Permission |\n|---------|-------------|------------|\n| `/ticket panel <number>` | Send a ticket panel | Manage Channels |\n| `/ticket add <user>` | Add user to ticket | Manage Channels |\n| `/ticket remove <user>` | Remove user from ticket | Manage Channels |\n| `/stats` | View support statistics | Manage Guild |\n| `/logs [limit]` | View recent ticket logs | Manage Guild |\n| `/settings` | Configure bot settings | Administrator |\n| `/blacklist add/remove/list <user>` | Manage blacklist | Manage Guild |\n\n### Staff Commands\n| Command | Description | Permission |\n|---------|-------------|------------|\n| `/claim ticket` | Claim current ticket | Manage Messages |\n| `/claim unclaim` | Unclaim current ticket | Manage Messages |\n| `/priority <level>` | Set ticket priority | Manage Messages |\n| `/tag add/remove/list <tag>` | Manage ticket tags | Manage Messages |\n| `/close [reason]` | Close ticket | Manage Messages |\n| `/transcript` | Generate transcript | Manage Messages |\n| `/feedback view <ticket>` | View feedback | Manage Messages |\n\n### General Commands\n| Command | Description |\n|---------|-------------|\n| `/reload` | Reload configuration |\n\n---\n\n## üé® Customization\n\n### Language Files\n\nCreate `lang/<code>.yml` for additional languages:\n\n```yaml\n# lang/es.yml - Spanish\ngeneral:\n  error: \"‚ùå Ocurri√≥ un error.\"\n  success: \"‚úÖ Operaci√≥n completada!\"\n\nticket_create:\n  created: \"üé´ Tu ticket ha sido creado!\"\n```\n\n### Custom Tags\n\nAdd tags in `config.yml`:\n\n```yaml\navailable_tags:\n  - \"Billing\"\n  - \"Technical\"\n  - \"Bug Report\"\n  - \"Feature Request\"\n  - \"Refund\"\n```\n\n---\n\n## üß© Addon System\n\nCreate custom addons in the `/addons` directory:\n\n```javascript\n// addons/my-addon.js\nexport default {\n  name: 'My Custom Addon',\n  version: '1.0.0',\n  description: 'Does something cool',\n  author: 'Your Name',\n\n  async onLoad(client) {\n    console.log('Addon loaded!');\n    // Add your custom functionality\n  },\n\n  async onUnload() {\n    console.log('Addon unloaded!');\n  }\n};\n```\n\n---\n\n## üìä Analytics & Insights\n\nThe bot tracks comprehensive statistics:\n\n- **Total Tickets** - All-time ticket count\n- **Response Time** - Average first response time\n- **Resolution Time** - Average time to close\n- **Customer Ratings** - Average satisfaction score\n- **Staff Performance** - Individual staff metrics\n- **Category Analysis** - Busiest support categories\n\nAccess via `/stats` command.\n\n---\n\n## üì¶ Project Structure\n\n```\ndiscord-ticket-bot/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ commands/         # Slash commands\n‚îÇ   ‚îú‚îÄ‚îÄ events/           # Discord event handlers\n‚îÇ   ‚îú‚îÄ‚îÄ utils/            # Utility modules\n‚îÇ   ‚îî‚îÄ‚îÄ types/            # TypeScript types\n‚îú‚îÄ‚îÄ lang/                 # Language files\n‚îú‚îÄ‚îÄ addons/               # Custom addons\n‚îú‚îÄ‚îÄ data/                 # Persistent data\n‚îú‚îÄ‚îÄ logs/                 # Log files\n‚îú‚îÄ‚îÄ transcripts/          # Generated transcripts\n‚îú‚îÄ‚îÄ config.yml            # Main configuration\n‚îú‚îÄ‚îÄ ticket-panels.yml     # Ticket panel definitions\n‚îú‚îÄ‚îÄ .env.example          # Environment template\n‚îú‚îÄ‚îÄ Dockerfile            # Docker configuration\n‚îú‚îÄ‚îÄ docker-compose.yml    # Docker Compose setup\n‚îî‚îÄ‚îÄ index.ts              # Entry point\n```\n\n---\n\n## üêõ Troubleshooting\n\n### Bot doesn't respond to commands\n- Check bot token in `config.yml` or `.env`\n- Verify bot has proper permissions\n- Ensure application commands are registered\n\n### Tickets not creating\n- Check `ticket_category_id` is valid\n- Verify bot can create channels in category\n- Check staff roles are configured correctly\n\n### Automation not working\n- Ensure automation features are enabled in config\n- Check working hours configuration\n- Verify timezone settings\n\n---\n\n## üìù License\n\nISC License - See LICENSE file for details\n\n---\n\n**Made with ‚ù§Ô∏è for the Discord community**\n","size_bytes":8254},"index.ts":{"content":"import { Client, GatewayIntentBits, Collection, REST, Routes } from 'discord.js';\nimport { ConfigHandler } from './src/utils/configHandler.js';\nimport { Lang } from './src/utils/languageManager.js';\nimport { AutomationManager } from './src/utils/automationManager.js';\nimport { AddonManager } from './src/utils/addonManager.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport chalk from 'chalk';\n\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMembers,\n    GatewayIntentBits.DirectMessages,\n  ],\n});\n\nasync function loadCommands() {\n  const commands: any[] = [];\n  const commandsPath = path.join(process.cwd(), 'src', 'commands');\n  const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.ts'));\n\n  for (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = await import(filePath);\n    if (command.data) {\n      commands.push(command.data.toJSON());\n      console.log(chalk.cyan(`üìå Loaded command: ${command.data.name}`));\n    }\n  }\n\n  return commands;\n}\n\nasync function registerCommands(commands: any[], config: any) {\n  try {\n    const rest = new REST({ version: '10' }).setToken(config.token);\n    \n    console.log(chalk.yellow('‚åõ Registering application commands...'));\n    \n    await rest.put(\n      Routes.applicationGuildCommands(client.user!.id, config.guild_id),\n      { body: commands }\n    );\n    \n    console.log(chalk.green(`‚úÖ Successfully registered ${commands.length} application commands`));\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error registering commands:'), error);\n  }\n}\n\nasync function loadEvents() {\n  const eventsPath = path.join(process.cwd(), 'src', 'events');\n  const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.ts'));\n\n  for (const file of eventFiles) {\n    const filePath = path.join(eventsPath, file);\n    const event = await import(filePath);\n    const eventName = file.replace('.ts', '');\n    \n    client.on(eventName, (...args) => event.execute(...args));\n    console.log(chalk.cyan(`üìå Loaded event: ${eventName}`));\n  }\n}\n\nfunction printBanner() {\n  console.log(chalk.magenta(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                                               ‚ïë\n‚ïë          Advanced Discord Ticket Bot v2.0                     ‚ïë\n‚ïë          Production-Ready Support System                      ‚ïë\n‚ïë                                                               ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n  `));\n}\n\nfunction runDiagnostics() {\n  console.log(chalk.cyan('\\nüîç Running startup diagnostics...\\n'));\n\n  // Check for required files\n  const requiredFiles = [\n    'config.yml',\n    'ticket-panels.yml',\n    'lang/en.yml'\n  ];\n\n  const missingFiles: string[] = [];\n\n  for (const file of requiredFiles) {\n    if (!fs.existsSync(file)) {\n      missingFiles.push(file);\n      console.log(chalk.red(`  ‚ùå Missing: ${file}`));\n    } else {\n      console.log(chalk.green(`  ‚úÖ Found: ${file}`));\n    }\n  }\n\n  // Check for required directories\n  const requiredDirs = ['data', 'logs', 'transcripts', 'addons'];\n  \n  for (const dir of requiredDirs) {\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n      console.log(chalk.yellow(`  üìÅ Created directory: ${dir}`));\n    } else {\n      console.log(chalk.green(`  ‚úÖ Directory exists: ${dir}`));\n    }\n  }\n\n  if (missingFiles.length > 0) {\n    console.log(chalk.red('\\n‚ö†Ô∏è Warning: Some required files are missing. The bot may not function correctly.'));\n  } else {\n    console.log(chalk.green('\\n‚úÖ All required files and directories are present!'));\n  }\n\n  console.log('');\n}\n\nasync function main() {\n  try {\n    printBanner();\n    runDiagnostics();\n\n    console.log(chalk.yellow('‚åõ Loading configuration...'));\n    const config = ConfigHandler.loadConfig();\n    ConfigHandler.loadPanels();\n\n    // Set language\n    if (config.language) {\n      Lang.setLanguage(config.language);\n      console.log(chalk.green(`‚úÖ Language set to: ${config.language}`));\n    }\n\n    console.log(chalk.yellow('‚åõ Loading commands...'));\n    const commands = await loadCommands();\n\n    console.log(chalk.yellow('‚åõ Loading events...'));\n    await loadEvents();\n\n    console.log(chalk.yellow('‚åõ Connecting to Discord...'));\n    await client.login(config.token);\n\n    // Wait for client to be ready\n    client.once('ready', async () => {\n      console.log(chalk.green(`‚úÖ Logged in as ${client.user!.tag}`));\n      \n      // Register commands\n      await registerCommands(commands, config);\n\n      // Start automation monitoring if enabled\n      if (config.features?.auto_close) {\n        AutomationManager.startMonitoring(client);\n        console.log(chalk.green('‚úÖ Automation monitoring started'));\n      }\n\n      // Load addons if enabled\n      if (config.features?.addons) {\n        await AddonManager.loadAll(client);\n        const loadedAddons = AddonManager.getLoaded();\n        console.log(chalk.green(`‚úÖ Loaded ${loadedAddons.length} addon(s)`));\n      }\n\n      console.log(chalk.green('\\nüöÄ Bot is now fully operational!\\n'));\n      console.log(chalk.cyan(`Bot Name: ${config.bot_name || 'Advanced Support Bot'}`));\n      console.log(chalk.cyan(`Guild ID: ${config.guild_id}`));\n      console.log(chalk.cyan(`Language: ${config.language || 'en'}`));\n      console.log(chalk.cyan(`Commands: ${commands.length}`));\n      console.log(chalk.cyan(`Features Enabled:`));\n      console.log(chalk.cyan(`  - Auto-Close: ${config.features?.auto_close ? '‚úÖ' : '‚ùå'}`));\n      console.log(chalk.cyan(`  - AI Responses: ${config.features?.ai_responses ? '‚úÖ' : '‚ùå'}`));\n      console.log(chalk.cyan(`  - Working Hours: ${config.features?.working_hours ? '‚úÖ' : '‚ùå'}`));\n      console.log(chalk.cyan(`  - Ticket Reviews: ${config.features?.ticket_reviews ? '‚úÖ' : '‚ùå'}`));\n      console.log(chalk.cyan(`  - Transcripts: ${config.features?.transcripts ? '‚úÖ' : '‚ùå'}`));\n      console.log(chalk.cyan(`  - Addons: ${config.features?.addons ? '‚úÖ' : '‚ùå'}`));\n      console.log('');\n    });\n\n    // Graceful shutdown\n    process.on('SIGINT', async () => {\n      console.log(chalk.yellow('\\n‚ö†Ô∏è Shutting down gracefully...'));\n      AutomationManager.stopMonitoring();\n      await client.destroy();\n      console.log(chalk.green('‚úÖ Bot shut down successfully'));\n      process.exit(0);\n    });\n\n  } catch (error) {\n    console.error(chalk.red('‚ùå Fatal error:'), error);\n    process.exit(1);\n  }\n}\n\nmain();\n","size_bytes":6946},"src/commands/settings.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  ActionRowBuilder,\n  ButtonBuilder,\n  ButtonStyle,\n  PermissionFlagsBits,\n  StringSelectMenuBuilder,\n  StringSelectMenuOptionBuilder,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { Lang } from '../utils/languageManager.js';\n\nexport const data = new SlashCommandBuilder()\n  .setName('settings')\n  .setDescription('Configure ticket system settings')\n  .setDefaultMemberPermissions(PermissionFlagsBits.Administrator);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n\n    const embed = new EmbedBuilder()\n      .setTitle(Lang.t('settings.title'))\n      .setDescription(Lang.t('settings.menu_description'))\n      .setColor(config.embed_color)\n      .addFields(\n        {\n          name: 'ü§ñ AI Responses',\n          value: config.features.ai_responses ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: 'üîí Auto-Close',\n          value: config.features.auto_close ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: '‚è∞ Working Hours',\n          value: config.features.working_hours ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: '‚≠ê Ticket Reviews',\n          value: config.features.ticket_reviews ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: 'üìÑ Transcripts',\n          value: config.features.transcripts ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: 'üß© Addons',\n          value: config.features.addons ? '‚úÖ Enabled' : '‚ùå Disabled',\n          inline: true,\n        },\n        {\n          name: '‚è±Ô∏è Inactivity Timeout',\n          value: `${config.automation.inactivity_timeout} minutes`,\n          inline: true,\n        },\n        {\n          name: '‚ö†Ô∏è Inactivity Warning',\n          value: `${config.automation.inactivity_warning} minutes`,\n          inline: true,\n        },\n        {\n          name: 'üìä Ticket Limit Per User',\n          value: config.automation.max_tickets_per_user.toString(),\n          inline: true,\n        }\n      )\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    const row1 = new ActionRowBuilder<ButtonBuilder>().addComponents(\n      new ButtonBuilder()\n        .setCustomId('toggle_ai')\n        .setLabel('Toggle AI')\n        .setEmoji('ü§ñ')\n        .setStyle(ButtonStyle.Primary),\n      new ButtonBuilder()\n        .setCustomId('toggle_autoclose')\n        .setLabel('Toggle Auto-Close')\n        .setEmoji('üîí')\n        .setStyle(ButtonStyle.Primary),\n      new ButtonBuilder()\n        .setCustomId('toggle_reviews')\n        .setLabel('Toggle Reviews')\n        .setEmoji('‚≠ê')\n        .setStyle(ButtonStyle.Primary)\n    );\n\n    const row2 = new ActionRowBuilder<ButtonBuilder>().addComponents(\n      new ButtonBuilder()\n        .setCustomId('reload_config')\n        .setLabel('Reload Config')\n        .setEmoji('üîÑ')\n        .setStyle(ButtonStyle.Success),\n      new ButtonBuilder()\n        .setCustomId('view_tags')\n        .setLabel('View Tags')\n        .setEmoji('üè∑Ô∏è')\n        .setStyle(ButtonStyle.Secondary)\n    );\n\n    await interaction.reply({\n      embeds: [embed],\n      components: [row1, row2],\n      ephemeral: true,\n    });\n  } catch (error) {\n    console.error('Error in settings command:', error);\n    await interaction.reply({\n      content: Lang.t('general.error'),\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":3645},"src/utils/feedbackManager.ts":{"content":"import * as fs from 'fs';\nimport { User, EmbedBuilder, TextChannel } from 'discord.js';\nimport { ConfigHandler } from './configHandler.js';\nimport chalk from 'chalk';\n\ninterface FeedbackEntry {\n  ticketId: string;\n  userId: string;\n  userName: string;\n  rating: number;\n  timestamp: string;\n}\n\nexport class FeedbackManager {\n  private static feedbackPath = 'data/feedback.json';\n\n  private static loadFeedback(): FeedbackEntry[] {\n    try {\n      if (!fs.existsSync(this.feedbackPath)) {\n        fs.writeFileSync(this.feedbackPath, '[]');\n      }\n      const data = fs.readFileSync(this.feedbackPath, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading feedback:'), error);\n      return [];\n    }\n  }\n\n  private static saveFeedback(feedback: FeedbackEntry[]): void {\n    try {\n      fs.writeFileSync(this.feedbackPath, JSON.stringify(feedback, null, 2));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error saving feedback:'), error);\n    }\n  }\n\n  static async sendFeedbackPrompt(user: User, ticketId: string): Promise<void> {\n    try {\n      const config = ConfigHandler.getConfig();\n      const { EmbedBuilder, ButtonBuilder, ActionRowBuilder, ButtonStyle } = await import('discord.js');\n      \n      const embed = new EmbedBuilder()\n        .setTitle('‚≠ê Review Your Ticket')\n        .setDescription('Please rate your support experience!')\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(\n        new ButtonBuilder()\n          .setCustomId(`rating_${ticketId}_1`)\n          .setLabel('‚≠ê')\n          .setStyle(ButtonStyle.Secondary),\n        new ButtonBuilder()\n          .setCustomId(`rating_${ticketId}_2`)\n          .setLabel('‚≠ê‚≠ê')\n          .setStyle(ButtonStyle.Secondary),\n        new ButtonBuilder()\n          .setCustomId(`rating_${ticketId}_3`)\n          .setLabel('‚≠ê‚≠ê‚≠ê')\n          .setStyle(ButtonStyle.Secondary),\n        new ButtonBuilder()\n          .setCustomId(`rating_${ticketId}_4`)\n          .setLabel('‚≠ê‚≠ê‚≠ê‚≠ê')\n          .setStyle(ButtonStyle.Primary),\n        new ButtonBuilder()\n          .setCustomId(`rating_${ticketId}_5`)\n          .setLabel('‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê')\n          .setStyle(ButtonStyle.Success)\n      );\n\n      await user.send({ embeds: [embed], components: [buttons] });\n      console.log(chalk.green(`‚úÖ Feedback prompt sent to ${user.tag}`));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error sending feedback prompt:'), error);\n    }\n  }\n\n  static async recordFeedback(\n    user: User,\n    ticketId: string,\n    rating: number,\n    feedbackChannel: TextChannel\n  ): Promise<void> {\n    try {\n      const config = ConfigHandler.getConfig();\n      const feedback = this.loadFeedback();\n\n      const entry: FeedbackEntry = {\n        ticketId,\n        userId: user.id,\n        userName: user.tag,\n        rating,\n        timestamp: new Date().toISOString(),\n      };\n\n      feedback.push(entry);\n      this.saveFeedback(feedback);\n\n      const stars = '‚≠ê'.repeat(rating);\n      const embed = new EmbedBuilder()\n        .setTitle('üìä New Feedback Received')\n        .setDescription(`**User:** ${user}\\n**Ticket:** ${ticketId}\\n**Rating:** ${stars} (${rating}/5)`)\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await feedbackChannel.send({ embeds: [embed] });\n\n      await user.send({\n        embeds: [\n          new EmbedBuilder()\n            .setTitle('‚úÖ Thank You!')\n            .setDescription(`Your feedback has been recorded: ${stars}`)\n            .setColor(config.embed_color)\n            .setFooter({ text: config.footer_text })\n            .setTimestamp(),\n        ],\n      });\n\n      console.log(chalk.green(`‚úÖ Feedback recorded: ${rating} stars from ${user.tag}`));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error recording feedback:'), error);\n    }\n  }\n\n  static getAllFeedback(): FeedbackEntry[] {\n    return this.loadFeedback();\n  }\n}\n","size_bytes":4121},"src/utils/logger.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport { LogEntry, LogType } from '../types/index.js';\nimport { format } from 'date-fns';\nimport chalk from 'chalk';\nimport { EmbedBuilder, TextChannel, Client } from 'discord.js';\nimport { ConfigHandler } from './configHandler.js';\n\nexport class Logger {\n  private static logsDir = path.join(process.cwd(), 'logs');\n  private static dataFile = path.join(process.cwd(), 'data', 'logs.json');\n  private static logs: LogEntry[] = [];\n\n  static {\n    // Ensure directories exist\n    if (!fs.existsSync(this.logsDir)) {\n      fs.mkdirSync(this.logsDir, { recursive: true });\n    }\n    if (!fs.existsSync(path.dirname(this.dataFile))) {\n      fs.mkdirSync(path.dirname(this.dataFile), { recursive: true });\n    }\n    this.loadLogs();\n  }\n\n  private static loadLogs(): void {\n    try {\n      if (fs.existsSync(this.dataFile)) {\n        const data = fs.readFileSync(this.dataFile, 'utf8');\n        this.logs = JSON.parse(data);\n      }\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading logs:'), error);\n      this.logs = [];\n    }\n  }\n\n  private static saveLogs(): void {\n    try {\n      fs.writeFileSync(this.dataFile, JSON.stringify(this.logs, null, 2));\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error saving logs:'), error);\n    }\n  }\n\n  public static log(\n    type: LogType,\n    userId: string,\n    username: string,\n    details: string,\n    ticketId?: string,\n    metadata?: any\n  ): LogEntry {\n    const entry: LogEntry = {\n      timestamp: Date.now(),\n      type,\n      userId,\n      username,\n      details,\n      ticketId,\n      metadata,\n    };\n\n    this.logs.push(entry);\n    this.saveLogs();\n    this.writeToFile(entry);\n\n    console.log(chalk.gray(`[LOG] ${type}: ${details}`));\n    return entry;\n  }\n\n  private static writeToFile(entry: LogEntry): void {\n    const date = format(new Date(entry.timestamp), 'yyyy-MM-dd');\n    const logFile = path.join(this.logsDir, `${date}.log`);\n    \n    const logLine = `[${format(new Date(entry.timestamp), 'yyyy-MM-dd HH:mm:ss')}] [${entry.type}] ${entry.username} (${entry.userId}) - ${entry.details}${entry.ticketId ? ` | Ticket: ${entry.ticketId}` : ''}\\n`;\n    \n    fs.appendFileSync(logFile, logLine);\n  }\n\n  public static async sendToLogChannel(client: Client, entry: LogEntry): Promise<void> {\n    try {\n      const config = ConfigHandler.getConfig();\n      if (!config.log_channel_id) return;\n\n      const channel = await client.channels.fetch(config.log_channel_id) as TextChannel;\n      if (!channel) return;\n\n      const embed = new EmbedBuilder()\n        .setTitle(this.getLogTitle(entry.type))\n        .setDescription(entry.details)\n        .setColor(this.getLogColor(entry.type))\n        .addFields(\n          { name: 'User', value: `${entry.username} (${entry.userId})`, inline: true },\n          { name: 'Type', value: entry.type, inline: true },\n          { name: 'Timestamp', value: `<t:${Math.floor(entry.timestamp / 1000)}:F>`, inline: false }\n        )\n        .setTimestamp(entry.timestamp);\n\n      if (entry.ticketId) {\n        embed.addFields({ name: 'Ticket ID', value: entry.ticketId, inline: true });\n      }\n\n      await channel.send({ embeds: [embed] });\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error sending log to channel:'), error);\n    }\n  }\n\n  private static getLogTitle(type: LogType): string {\n    const titles: { [key in LogType]: string } = {\n      [LogType.TICKET_CREATED]: 'üé´ Ticket Created',\n      [LogType.TICKET_CLOSED]: 'üîí Ticket Closed',\n      [LogType.TICKET_REOPENED]: 'üîì Ticket Reopened',\n      [LogType.TICKET_DELETED]: 'üóëÔ∏è Ticket Deleted',\n      [LogType.TICKET_CLAIMED]: '‚úã Ticket Claimed',\n      [LogType.TICKET_UNCLAIMED]: 'üëã Ticket Unclaimed',\n      [LogType.PRIORITY_CHANGED]: 'üéØ Priority Changed',\n      [LogType.TAG_ADDED]: 'üè∑Ô∏è Tag Added',\n      [LogType.TAG_REMOVED]: 'üè∑Ô∏è Tag Removed',\n      [LogType.MEMBER_ADDED]: '‚ûï Member Added',\n      [LogType.MEMBER_REMOVED]: '‚ûñ Member Removed',\n      [LogType.RATING_SUBMITTED]: '‚≠ê Rating Submitted',\n    };\n    return titles[type] || type;\n  }\n\n  private static getLogColor(type: LogType): number {\n    const colors: { [key in LogType]: number } = {\n      [LogType.TICKET_CREATED]: 0x00ff00,\n      [LogType.TICKET_CLOSED]: 0xff0000,\n      [LogType.TICKET_REOPENED]: 0x00ff00,\n      [LogType.TICKET_DELETED]: 0x808080,\n      [LogType.TICKET_CLAIMED]: 0x5865f2,\n      [LogType.TICKET_UNCLAIMED]: 0x5865f2,\n      [LogType.PRIORITY_CHANGED]: 0xffaa00,\n      [LogType.TAG_ADDED]: 0x00ffff,\n      [LogType.TAG_REMOVED]: 0x00ffff,\n      [LogType.MEMBER_ADDED]: 0x00ff00,\n      [LogType.MEMBER_REMOVED]: 0xff0000,\n      [LogType.RATING_SUBMITTED]: 0xffd700,\n    };\n    return colors[type] || 0x5865f2;\n  }\n\n  public static getRecentLogs(limit: number = 20): LogEntry[] {\n    return this.logs.slice(-limit).reverse();\n  }\n\n  public static getLogsByTicket(ticketId: string): LogEntry[] {\n    return this.logs.filter(log => log.ticketId === ticketId);\n  }\n\n  public static getLogsByType(type: LogType): LogEntry[] {\n    return this.logs.filter(log => log.type === type);\n  }\n\n  public static clearOldLogs(daysToKeep: number = 30): void {\n    const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);\n    this.logs = this.logs.filter(log => log.timestamp > cutoffTime);\n    this.saveLogs();\n    console.log(chalk.green(`‚úÖ Cleared logs older than ${daysToKeep} days`));\n  }\n}\n","size_bytes":5468},"src/utils/transcriptGenerator.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport { TextChannel, Message, Collection, AttachmentBuilder } from 'discord.js';\nimport { TicketData } from '../types/index.js';\nimport { format } from 'date-fns';\nimport { ConfigHandler } from './configHandler.js';\nimport chalk from 'chalk';\n\nexport class TranscriptGenerator {\n  private static transcriptsDir = path.join(process.cwd(), 'transcripts');\n\n  static {\n    if (!fs.existsSync(this.transcriptsDir)) {\n      fs.mkdirSync(this.transcriptsDir, { recursive: true });\n    }\n  }\n\n  // Modern HTML transcript from ticket data\n  static async generateHTML(ticket: TicketData): Promise<string> {\n    const config = ConfigHandler.getConfig();\n    const timestamp = format(new Date(ticket.createdAt), 'yyyy-MM-dd_HH-mm-ss');\n    const filename = `${ticket.ticketId}_${timestamp}.html`;\n    const filepath = path.join(this.transcriptsDir, filename);\n\n    const html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ticket Transcript - ${ticket.ticketId}</title>\n    <style>\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            padding: 20px;\n            line-height: 1.6;\n        }\n        \n        .container {\n            max-width: 900px;\n            margin: 0 auto;\n            background: white;\n            border-radius: 15px;\n            box-shadow: 0 10px 40px rgba(0,0,0,0.2);\n            overflow: hidden;\n        }\n        \n        .header {\n            background: linear-gradient(135deg, #5865f2, #7289da);\n            color: white;\n            padding: 30px;\n            text-align: center;\n        }\n        \n        .header h1 { font-size: 2em; margin-bottom: 10px; }\n        \n        .info-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            padding: 30px;\n            background: #f8f9fa;\n        }\n        \n        .info-item {\n            background: white;\n            padding: 15px;\n            border-radius: 8px;\n            border-left: 4px solid #5865f2;\n        }\n        \n        .info-item label {\n            display: block;\n            font-weight: bold;\n            color: #5865f2;\n            margin-bottom: 5px;\n            font-size: 0.85em;\n            text-transform: uppercase;\n        }\n        \n        .messages {\n            padding: 30px;\n        }\n        \n        .message {\n            margin-bottom: 20px;\n            padding: 15px;\n            border-radius: 10px;\n            background: #f8f9fa;\n            border-left: 4px solid #5865f2;\n            transition: transform 0.2s;\n        }\n        \n        .message:hover { transform: translateX(5px); }\n        \n        .message-header {\n            display: flex;\n            align-items: center;\n            margin-bottom: 10px;\n        }\n        \n        .message-author {\n            font-weight: bold;\n            color: #5865f2;\n            margin-right: 10px;\n        }\n        \n        .message-time { color: #999; font-size: 0.85em; }\n        \n        .message-content {\n            color: #333;\n            white-space: pre-wrap;\n            word-wrap: break-word;\n        }\n        \n        .tags {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 8px;\n            margin-top: 10px;\n        }\n        \n        .tag {\n            background: #5865f2;\n            color: white;\n            padding: 5px 12px;\n            border-radius: 15px;\n            font-size: 0.85em;\n        }\n        \n        .rating {\n            text-align: center;\n            padding: 30px;\n            background: #fff3cd;\n            border-top: 3px solid #ffc107;\n        }\n        \n        .rating h3 { color: #856404; margin-bottom: 10px; }\n        .stars { font-size: 2em; color: #ffc107; }\n        \n        .footer {\n            background: #343a40;\n            color: white;\n            text-align: center;\n            padding: 20px;\n            font-size: 0.9em;\n        }\n        \n        .priority {\n            display: inline-block;\n            padding: 5px 15px;\n            border-radius: 20px;\n            font-weight: bold;\n            font-size: 0.9em;\n        }\n        \n        .priority-low { background: #00ff00; color: #000; }\n        .priority-medium { background: #ffff00; color: #000; }\n        .priority-high { background: #ff8800; color: #fff; }\n        .priority-urgent { background: #ff0000; color: #fff; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>üìÑ Ticket Transcript</h1>\n            <p>${config.bot_name || 'Support System'}</p>\n        </div>\n        \n        <div class=\"info-grid\">\n            <div class=\"info-item\"><label>Ticket ID</label><value>${ticket.ticketId}</value></div>\n            <div class=\"info-item\"><label>Category</label><value>${ticket.category}</value></div>\n            <div class=\"info-item\"><label>User</label><value>${ticket.username}</value></div>\n            <div class=\"info-item\"><label>Priority</label><value><span class=\"priority priority-${ticket.priority}\">${ticket.priority.toUpperCase()}</span></value></div>\n            <div class=\"info-item\"><label>Created</label><value>${format(new Date(ticket.createdAt), 'MMM dd, yyyy HH:mm')}</value></div>\n            <div class=\"info-item\"><label>Status</label><value>${ticket.status.toUpperCase()}</value></div>\n            ${ticket.claimedByUsername ? `<div class=\"info-item\"><label>Claimed By</label><value>${ticket.claimedByUsername}</value></div>` : ''}\n            ${ticket.tags.length > 0 ? `<div class=\"info-item\" style=\"grid-column: 1 / -1;\"><label>Tags</label><div class=\"tags\">${ticket.tags.map(tag => `<span class=\"tag\">${tag}</span>`).join('')}</div></div>` : ''}\n        </div>\n        \n        <div class=\"messages\">\n            <h2 style=\"margin-bottom: 20px; color: #333;\">Messages</h2>\n            ${ticket.messages.map(msg => `\n                <div class=\"message\">\n                    <div class=\"message-header\">\n                        <span class=\"message-author\">${msg.authorUsername}</span>\n                        <span class=\"message-time\">${format(new Date(msg.timestamp), 'MMM dd, yyyy HH:mm:ss')}</span>\n                    </div>\n                    <div class=\"message-content\">${this.escapeHTML(msg.content)}</div>\n                    ${msg.attachments && msg.attachments.length > 0 ? `<div style=\"margin-top: 10px; font-size: 0.9em; color: #666;\">üìé Attachments: ${msg.attachments.map(a => `<a href=\"${a}\" target=\"_blank\">${a}</a>`).join(', ')}</div>` : ''}\n                </div>\n            `).join('')}\n        </div>\n        \n        ${ticket.rating ? `\n        <div class=\"rating\">\n            <h3>Customer Feedback</h3>\n            <div class=\"stars\">${'‚≠ê'.repeat(ticket.rating)}</div>\n            <p style=\"margin-top: 10px; color: #856404;\">${ticket.rating}/5 Stars</p>\n            ${ticket.feedbackText ? `<p style=\"margin-top: 10px; color: #333;\"><em>\"${this.escapeHTML(ticket.feedbackText)}\"</em></p>` : ''}\n        </div>\n        ` : ''}\n        \n        <div class=\"footer\">\n            <p>${config.footer_text || 'Support System ¬© 2025'}</p>\n            <p style=\"margin-top: 5px; font-size: 0.85em;\">Generated on ${format(new Date(), 'MMMM dd, yyyy HH:mm:ss')}</p>\n        </div>\n    </div>\n</body>\n</html>\n    `;\n\n    fs.writeFileSync(filepath, html);\n    console.log(chalk.green(`‚úÖ HTML transcript generated: ${filename}`));\n    return filepath;\n  }\n\n  static async generateTXT(ticket: TicketData): Promise<string> {\n    const config = ConfigHandler.getConfig();\n    const timestamp = format(new Date(ticket.createdAt), 'yyyy-MM-dd_HH-mm-ss');\n    const filename = `${ticket.ticketId}_${timestamp}.txt`;\n    const filepath = path.join(this.transcriptsDir, filename);\n\n    let content = `\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                      TICKET TRANSCRIPT                          ‚ïë\n‚ïë                    ${config.bot_name || 'Support System'}                          ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\nTICKET INFORMATION\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nTicket ID:      ${ticket.ticketId}\nCategory:       ${ticket.category}\nUser:           ${ticket.username} (${ticket.userId})\nPriority:       ${ticket.priority.toUpperCase()}\nStatus:         ${ticket.status.toUpperCase()}\nCreated:        ${format(new Date(ticket.createdAt), 'MMMM dd, yyyy HH:mm:ss')}\n${ticket.claimedByUsername ? `Claimed By:     ${ticket.claimedByUsername}\\n` : ''}${ticket.tags.length > 0 ? `Tags:           ${ticket.tags.join(', ')}\\n` : ''}\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nMESSAGES\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n${ticket.messages.map(msg => `\n[${format(new Date(msg.timestamp), 'yyyy-MM-dd HH:mm:ss')}] ${msg.authorUsername}:\n${msg.content}\n${msg.attachments && msg.attachments.length > 0 ? `Attachments: ${msg.attachments.join(', ')}\\n` : ''}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`).join('\\n')}\n\n${ticket.rating ? `\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nCUSTOMER FEEDBACK\nRating: ${'‚òÖ'.repeat(ticket.rating)}${'‚òÜ'.repeat(5 - ticket.rating)} (${ticket.rating}/5)\n${ticket.feedbackText ? `Feedback: ${ticket.feedbackText}\\n` : ''}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` : ''}\nGenerated: ${format(new Date(), 'MMMM dd, yyyy HH:mm:ss')}\n${config.footer_text || 'Support System ¬© 2025'}\n    `;\n\n    fs.writeFileSync(filepath, content.trim());\n    console.log(chalk.green(`‚úÖ TXT transcript generated: ${filename}`));\n    return filepath;\n  }\n\n  static async generate(ticket: TicketData, formatType: 'html' | 'txt' | 'both' = 'html'): Promise<string[]> {\n    const files: string[] = [];\n\n    if (formatType === 'html' || formatType === 'both') {\n      files.push(await this.generateHTML(ticket));\n    }\n\n    if (formatType === 'txt' || formatType === 'both') {\n      files.push(await this.generateTXT(ticket));\n    }\n\n    return files;\n  }\n\n  static createAttachment(filepath: string): AttachmentBuilder {\n    return new AttachmentBuilder(filepath);\n  }\n\n  private static escapeHTML(text: string): string {\n    const map: { [key: string]: string } = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#039;',\n    };\n    return text.replace(/[&<>\"']/g, m => map[m]);\n  }\n\n  // Legacy methods for backward compatibility\n  static async generateHTMLTranscript(channel: TextChannel, ticketId: string): Promise<string | null> {\n    try {\n      const messages = await this.fetchAllMessages(channel);\n      const html = this.createLegacyHTML(messages, channel.name, ticketId);\n      \n      const filename = `${ticketId}_${Date.now()}.html`;\n      const filepath = path.join(this.transcriptsDir, filename);\n      \n      fs.writeFileSync(filepath, html);\n      console.log(chalk.green(`‚úÖ HTML transcript generated: ${filename}`));\n      return filepath;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error generating HTML transcript:'), error);\n      return null;\n    }\n  }\n\n  static async generateTextTranscript(channel: TextChannel, ticketId: string): Promise<string | null> {\n    try {\n      const messages = await this.fetchAllMessages(channel);\n      \n      let text = `=== Ticket Transcript: ${ticketId} ===\\n`;\n      text += `Channel: ${channel.name}\\n`;\n      text += `Generated: ${new Date().toISOString()}\\n`;\n      text += `Total Messages: ${messages.size}\\n\\n`;\n      text += `${'='.repeat(60)}\\n\\n`;\n\n      messages.reverse().forEach((msg) => {\n        const timestamp = format(msg.createdAt, 'yyyy-MM-dd HH:mm:ss');\n        text += `[${timestamp}] ${msg.author.tag}:\\n${msg.content}\\n\\n`;\n      });\n\n      const filename = `${ticketId}_${Date.now()}.txt`;\n      const filepath = path.join(this.transcriptsDir, filename);\n      \n      fs.writeFileSync(filepath, text);\n      console.log(chalk.green(`‚úÖ Text transcript generated: ${filename}`));\n      return filepath;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error generating text transcript:'), error);\n      return null;\n    }\n  }\n\n  private static async fetchAllMessages(channel: TextChannel): Promise<Collection<string, Message>> {\n    let allMessages = new Collection<string, Message>();\n    let lastMessageId: string | undefined;\n\n    while (true) {\n      const options: any = { limit: 100 };\n      if (lastMessageId) {\n        options.before = lastMessageId;\n      }\n\n      const fetchedMessages = await channel.messages.fetch(options);\n      \n      if (fetchedMessages.size === 0) break;\n      \n      allMessages = allMessages.concat(fetchedMessages);\n      lastMessageId = fetchedMessages.last()?.id;\n      \n      if (fetchedMessages.size < 100) break;\n    }\n\n    return allMessages;\n  }\n\n  private static createLegacyHTML(messages: Collection<string, Message>, channelName: string, ticketId: string): string {\n    const sortedMessages = Array.from(messages.values()).reverse();\n    const config = ConfigHandler.getConfig();\n\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Ticket Transcript - ${ticketId}</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #36393f; color: #dcddde; padding: 20px; }\n    .container { max-width: 1200px; margin: 0 auto; background: #2f3136; border-radius: 8px; padding: 30px; }\n    .header { border-bottom: 2px solid #5865f2; padding-bottom: 20px; margin-bottom: 30px; }\n    .header h1 { color: #5865f2; font-size: 28px; margin-bottom: 10px; }\n    .header .info { color: #b9bbbe; font-size: 14px; }\n    .message { display: flex; padding: 15px; margin-bottom: 15px; border-radius: 5px; background: #40444b; }\n    .message:hover { background: #42464d; }\n    .avatar { width: 40px; height: 40px; border-radius: 50%; background: #5865f2; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px; flex-shrink: 0; }\n    .message-content { flex: 1; }\n    .message-header { display: flex; align-items: baseline; margin-bottom: 5px; }\n    .username { font-weight: 600; color: #ffffff; margin-right: 8px; }\n    .timestamp { font-size: 12px; color: #72767d; }\n    .message-text { color: #dcddde; word-wrap: break-word; white-space: pre-wrap; }\n    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #4f545c; text-align: center; color: #72767d; font-size: 12px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1>üé´ ${ticketId}</h1>\n      <div class=\"info\">\n        <strong>Channel:</strong> #${channelName}<br>\n        <strong>Generated:</strong> ${format(new Date(), 'PPpp')}<br>\n        <strong>Messages:</strong> ${sortedMessages.length}\n      </div>\n    </div>\n    \n    <div class=\"messages\">\n      ${sortedMessages.map(msg => `\n        <div class=\"message\">\n          <div class=\"avatar\">${msg.author.username.charAt(0).toUpperCase()}</div>\n          <div class=\"message-content\">\n            <div class=\"message-header\">\n              <span class=\"username\">${msg.author.username}</span>\n              <span class=\"timestamp\">${format(msg.createdAt, 'PPpp')}</span>\n            </div>\n            <div class=\"message-text\">${this.escapeHTML(msg.content)}</div>\n          </div>\n        </div>\n      `).join('')}\n    </div>\n    \n    <div class=\"footer\">\n      ${config.footer_text || 'Support System ¬© 2025'} ‚Ä¢ Generated on ${format(new Date(), 'PPpp')}\n    </div>\n  </div>\n</body>\n</html>`;\n  }\n}\n","size_bytes":17083},"src/events/interactionCreate.ts":{"content":"import {\n  Interaction,\n  ModalBuilder,\n  TextInputBuilder,\n  TextInputStyle,\n  ActionRowBuilder,\n  EmbedBuilder,\n  ButtonBuilder,\n  ButtonStyle,\n  TextChannel,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport { BlacklistManager } from '../utils/blacklistManager.js';\nimport { FeedbackManager } from '../utils/feedbackManager.js';\nimport { TranscriptGenerator } from '../utils/transcriptGenerator.js';\nimport chalk from 'chalk';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport async function execute(interaction: Interaction) {\n  try {\n    if (interaction.isChatInputCommand()) {\n      const commandsPath = path.join(process.cwd(), 'src', 'commands');\n      const commandFile = `${interaction.commandName}.ts`;\n      const filePath = path.join(commandsPath, commandFile);\n\n      if (fs.existsSync(filePath)) {\n        const command = await import(filePath);\n        await command.execute(interaction);\n      }\n    } else if (interaction.isStringSelectMenu()) {\n      if (interaction.customId.startsWith('ticket_panel_')) {\n        await handleTicketPanelSelect(interaction);\n      }\n    } else if (interaction.isModalSubmit()) {\n      if (interaction.customId.startsWith('ticket_modal_')) {\n        await handleTicketModalSubmit(interaction);\n      }\n    } else if (interaction.isButton()) {\n      await handleButtonInteraction(interaction);\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in interactionCreate:'), error);\n  }\n}\n\nasync function handleTicketPanelSelect(interaction: any) {\n  try {\n    const config = ConfigHandler.getConfig();\n\n    if (BlacklistManager.isBlacklisted(interaction.user.id)) {\n      await interaction.reply({\n        content: config.blacklist_message,\n        ephemeral: true,\n      });\n      return;\n    }\n\n    const value = interaction.values[0];\n    const [, , panelNumber, categoryIndex] = value.split('_');\n\n    const panels = ConfigHandler.getPanels();\n    const panel = panels.panels[parseInt(panelNumber)];\n    const category = panel.categories[parseInt(categoryIndex)];\n\n    const modal = new ModalBuilder()\n      .setCustomId(`ticket_modal_${panelNumber}_${categoryIndex}`)\n      .setTitle(category.modal.title);\n\n    const components = category.modal.questions.map((question, index) => {\n      const textInput = new TextInputBuilder()\n        .setCustomId(`question_${index}`)\n        .setLabel(question.label)\n        .setStyle(\n          question.style === 'paragraph' ? TextInputStyle.Paragraph : TextInputStyle.Short\n        )\n        .setRequired(question.required);\n\n      return new ActionRowBuilder<TextInputBuilder>().addComponents(textInput);\n    });\n\n    modal.addComponents(...components);\n\n    await interaction.showModal(modal);\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error handling ticket panel select:'), error);\n  }\n}\n\nasync function handleTicketModalSubmit(interaction: any) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const [, , panelNumber, categoryIndex] = interaction.customId.split('_');\n\n    const panels = ConfigHandler.getPanels();\n    const panel = panels.panels[parseInt(panelNumber)];\n    const category = panel.categories[parseInt(categoryIndex)];\n\n    await interaction.reply({\n      content: '‚åõ Creating your ticket...',\n      ephemeral: true,\n    });\n\n    const answers: string[] = [];\n    category.modal.questions.forEach((question, index) => {\n      const answer = interaction.fields.getTextInputValue(`question_${index}`);\n      answers.push(`**${question.label}:**\\n${answer}`);\n    });\n\n    const ticketChannel = await TicketManager.createTicket(\n      interaction.guild,\n      interaction.user,\n      category.label,\n      answers\n    );\n\n    if (ticketChannel) {\n      await interaction.editReply({\n        content: `‚úÖ ${config.ticket_created_message}\\n${ticketChannel}`,\n      });\n    } else {\n      await interaction.editReply({\n        content: '‚ùå Failed to create ticket. Please try again.',\n      });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error handling ticket modal submit:'), error);\n  }\n}\n\nasync function handleButtonInteraction(interaction: any) {\n  try {\n    const config = ConfigHandler.getConfig();\n\n    if (interaction.customId === 'close_ticket') {\n      const member = interaction.member;\n      const hasPermission = config.staff_roles.some((roleId: string) =>\n        member.roles.cache.has(roleId)\n      ) || member.permissions.has(PermissionFlagsBits.ManageChannels);\n\n      if (!hasPermission) {\n        await interaction.reply({\n          content: '‚ùå Only staff members can close tickets.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n      if (!ticket) {\n        await interaction.reply({\n          content: '‚ùå This channel is not a ticket.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      await interaction.reply({\n        content: '‚åõ Closing ticket...',\n        ephemeral: true,\n      });\n\n      const channel = interaction.channel as TextChannel;\n      const transcriptPath = await TranscriptGenerator.generateHTMLTranscript(\n        channel,\n        ticket.ticketId\n      );\n\n      if (transcriptPath) {\n        const transcriptChannel = await interaction.guild.channels.fetch(\n          config.transcript_channel_id\n        ) as TextChannel;\n\n        if (transcriptChannel) {\n          const embed = new EmbedBuilder()\n            .setTitle(`üìú Ticket Transcript: ${ticket.ticketId}`)\n            .setDescription(\n              `**User:** <@${ticket.data.userId}>\\n**Category:** ${ticket.data.category}\\n**Closed by:** ${interaction.user}`\n            )\n            .setColor(config.embed_color)\n            .setFooter({ text: config.footer_text })\n            .setTimestamp();\n\n          await transcriptChannel.send({\n            embeds: [embed],\n            files: [transcriptPath],\n          });\n        }\n      }\n\n      const user = await interaction.client.users.fetch(ticket.data.userId);\n      await FeedbackManager.sendFeedbackPrompt(user, ticket.ticketId);\n\n      TicketManager.closeTicket(ticket.ticketId);\n\n      const closeEmbed = new EmbedBuilder()\n        .setTitle('üîí Ticket Closed')\n        .setDescription(\n          config.close_ticket_message.replace('{user}', interaction.user.toString())\n        )\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await channel.send({ embeds: [closeEmbed] });\n\n      setTimeout(async () => {\n        try {\n          await channel.delete();\n        } catch (error) {\n          console.error(chalk.red('‚ùå Error deleting channel:'), error);\n        }\n      }, 5000);\n    } else if (interaction.customId.startsWith('rating_')) {\n      const [, ticketId, ratingStr] = interaction.customId.split('_');\n      const rating = parseInt(ratingStr);\n\n      const allTickets = TicketManager.getAllTickets();\n      const ticketData = allTickets[ticketId];\n      \n      if (!ticketData) {\n        await interaction.update({\n          content: '‚ùå Ticket not found.',\n          embeds: [],\n          components: [],\n        });\n        return;\n      }\n\n      const guild = interaction.client.guilds.cache.get(ticketData.guildId);\n      if (!guild) {\n        await interaction.update({\n          content: '‚ùå Unable to process feedback at this time.',\n          embeds: [],\n          components: [],\n        });\n        return;\n      }\n\n      const feedbackChannel = await guild.channels.fetch(\n        config.feedback_channel_id\n      ) as TextChannel;\n\n      await FeedbackManager.recordFeedback(\n        interaction.user,\n        ticketId,\n        rating,\n        feedbackChannel\n      );\n\n      await interaction.update({\n        content: '‚úÖ Thank you for your feedback!',\n        embeds: [],\n        components: [],\n      });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error handling button interaction:'), error);\n  }\n}\n","size_bytes":8105},"src/commands/ticket.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n  ActionRowBuilder,\n  StringSelectMenuBuilder,\n  StringSelectMenuOptionBuilder,\n  TextChannel,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { TicketManager } from '../utils/ticketManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('ticket')\n  .setDescription('Manage ticket panels')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels)\n  .addSubcommand((subcommand) =>\n    subcommand\n      .setName('panel')\n      .setDescription('Send a ticket panel')\n      .addIntegerOption((option) =>\n        option\n          .setName('number')\n          .setDescription('Panel number to send')\n          .setRequired(true)\n      )\n  )\n  .addSubcommand((subcommand) =>\n    subcommand\n      .setName('add')\n      .setDescription('Add a member to the current ticket')\n      .addUserOption((option) =>\n        option\n          .setName('user')\n          .setDescription('User to add to the ticket')\n          .setRequired(true)\n      )\n  )\n  .addSubcommand((subcommand) =>\n    subcommand\n      .setName('remove')\n      .setDescription('Remove a member from the current ticket')\n      .addUserOption((option) =>\n        option\n          .setName('user')\n          .setDescription('User to remove from the ticket')\n          .setRequired(true)\n      )\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const subcommand = interaction.options.getSubcommand();\n\n    if (subcommand === 'panel') {\n      const panelNumber = interaction.options.getInteger('number', true);\n      const panels = ConfigHandler.getPanels();\n      const panel = panels.panels[panelNumber];\n\n      if (!panel) {\n        await interaction.reply({\n          content: `‚ùå Panel ${panelNumber} not found in ticket-panels.yml`,\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const embed = new EmbedBuilder()\n        .setTitle(panel.title)\n        .setDescription(panel.description)\n        .setColor(panel.color)\n        .setFooter({ text: panel.footer })\n        .setTimestamp();\n\n      const options = panel.categories.map((category, index) =>\n        new StringSelectMenuOptionBuilder()\n          .setLabel(category.label)\n          .setDescription(category.description)\n          .setEmoji(category.emoji)\n          .setValue(`ticket_category_${panelNumber}_${index}`)\n      );\n\n      const selectMenu = new StringSelectMenuBuilder()\n        .setCustomId(`ticket_panel_${panelNumber}`)\n        .setPlaceholder('Select a category...')\n        .addOptions(options);\n\n      const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(selectMenu);\n\n      await interaction.channel?.send({\n        embeds: [embed],\n        components: [row],\n      });\n\n      await interaction.reply({\n        content: '‚úÖ Ticket panel sent successfully!',\n        ephemeral: true,\n      });\n\n      console.log(chalk.green(`‚úÖ Panel ${panelNumber} sent by ${interaction.user.tag}`));\n    } else if (subcommand === 'add') {\n      const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n      if (!ticket) {\n        await interaction.reply({\n          content: '‚ùå This channel is not a ticket.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const user = interaction.options.getUser('user', true);\n      const channel = interaction.channel as TextChannel;\n\n      await channel.permissionOverwrites.create(user.id, {\n        ViewChannel: true,\n        SendMessages: true,\n        ReadMessageHistory: true,\n      });\n\n      const embed = new EmbedBuilder()\n        .setTitle('‚úÖ Member Added')\n        .setDescription(`${user} has been added to this ticket.`)\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed] });\n      console.log(chalk.green(`‚úÖ ${user.tag} added to ${ticket.ticketId} by ${interaction.user.tag}`));\n    } else if (subcommand === 'remove') {\n      const ticket = TicketManager.getTicketByChannel(interaction.channelId);\n\n      if (!ticket) {\n        await interaction.reply({\n          content: '‚ùå This channel is not a ticket.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const user = interaction.options.getUser('user', true);\n\n      if (user.id === ticket.data.userId) {\n        await interaction.reply({\n          content: '‚ùå You cannot remove the ticket owner.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const channel = interaction.channel as TextChannel;\n\n      await channel.permissionOverwrites.delete(user.id);\n\n      const embed = new EmbedBuilder()\n        .setTitle('‚úÖ Member Removed')\n        .setDescription(`${user} has been removed from this ticket.`)\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed] });\n      console.log(chalk.green(`‚úÖ ${user.tag} removed from ${ticket.ticketId} by ${interaction.user.tag}`));\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in ticket command:'), error);\n    await interaction.reply({\n      content: '‚ùå An error occurred while processing the command.',\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":5472},"src/commands/logs.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { Logger } from '../utils/logger.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { format } from 'date-fns';\n\nexport const data = new SlashCommandBuilder()\n  .setName('logs')\n  .setDescription('View recent ticket logs')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild)\n  .addIntegerOption(option =>\n    option\n      .setName('limit')\n      .setDescription('Number of logs to show (default: 10)')\n      .setMinValue(1)\n      .setMaxValue(50)\n      .setRequired(false)\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    await interaction.deferReply({ ephemeral: true });\n\n    const limit = interaction.options.getInteger('limit') || 10;\n    const config = ConfigHandler.getConfig();\n    const recentLogs = Logger.getRecentLogs(limit);\n\n    if (recentLogs.length === 0) {\n      await interaction.editReply({\n        content: 'No recent logs found.',\n      });\n      return;\n    }\n\n    const embed = new EmbedBuilder()\n      .setTitle('üìã Recent Ticket Logs')\n      .setDescription(\n        recentLogs\n          .map(log => {\n            const timestamp = format(new Date(log.timestamp), 'MMM dd HH:mm');\n            return `\\`${timestamp}\\` **${log.type}** - ${log.username}: ${log.details}`;\n          })\n          .join('\\n')\n      )\n      .setColor(config.embed_color)\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    await interaction.editReply({ embeds: [embed] });\n  } catch (error) {\n    console.error('Error in logs command:', error);\n    await interaction.editReply({\n      content: '‚ùå An error occurred while fetching logs.',\n    });\n  }\n}\n","size_bytes":1786},"src/commands/stats.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  EmbedBuilder,\n  PermissionFlagsBits,\n} from 'discord.js';\nimport { StatsManager } from '../utils/statsManager.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { Lang } from '../utils/languageManager.js';\n\nexport const data = new SlashCommandBuilder()\n  .setName('stats')\n  .setDescription('View support ticket statistics')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    await interaction.deferReply({ ephemeral: true });\n\n    const config = ConfigHandler.getConfig();\n    const stats = StatsManager.calculateStats();\n    const topStaff = StatsManager.getTopStaff();\n    const busiestCategory = StatsManager.getBusiestCategory();\n\n    const embed = new EmbedBuilder()\n      .setTitle(Lang.t('stats.title'))\n      .setColor(config.embed_color)\n      .addFields(\n        {\n          name: Lang.t('stats.total_tickets'),\n          value: stats.totalTickets.toString(),\n          inline: true,\n        },\n        {\n          name: Lang.t('stats.open_tickets'),\n          value: stats.openTickets.toString(),\n          inline: true,\n        },\n        {\n          name: Lang.t('stats.closed_tickets'),\n          value: stats.closedTickets.toString(),\n          inline: true,\n        },\n        {\n          name: Lang.t('stats.avg_response_time'),\n          value: `${stats.avgResponseTime} minutes`,\n          inline: true,\n        },\n        {\n          name: Lang.t('stats.avg_resolution_time'),\n          value: `${stats.avgResolutionTime} hours`,\n          inline: true,\n        },\n        {\n          name: Lang.t('stats.avg_rating'),\n          value: `${stats.avgRating}/5.0 ‚≠ê`,\n          inline: true,\n        }\n      )\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    if (topStaff) {\n      embed.addFields({\n        name: Lang.t('stats.top_staff'),\n        value: `${topStaff.username} (${topStaff.count} tickets)`,\n        inline: false,\n      });\n    }\n\n    if (busiestCategory) {\n      embed.addFields({\n        name: Lang.t('stats.busiest_category'),\n        value: `${busiestCategory.category} (${busiestCategory.count} tickets)`,\n        inline: false,\n      });\n    }\n\n    // Rating distribution\n    const ratingBars = Object.entries(stats.ratingDistribution)\n      .map(([rating, count]) => {\n        const percentage = stats.totalTickets > 0 ? (count / stats.totalTickets) * 100 : 0;\n        const barLength = Math.floor(percentage / 5);\n        const bar = '‚ñà'.repeat(barLength) + '‚ñë'.repeat(20 - barLength);\n        return `${rating}‚≠ê ${bar} ${count}`;\n      })\n      .reverse()\n      .join('\\n');\n\n    if (ratingBars) {\n      embed.addFields({\n        name: 'üìä Rating Distribution',\n        value: `\\`\\`\\`${ratingBars}\\`\\`\\``,\n        inline: false,\n      });\n    }\n\n    await interaction.editReply({ embeds: [embed] });\n  } catch (error) {\n    console.error('Error in stats command:', error);\n    await interaction.editReply({\n      content: Lang.t('general.error'),\n    });\n  }\n}\n","size_bytes":3125},"src/commands/blacklist.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport { BlacklistManager } from '../utils/blacklistManager.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('blacklist')\n  .setDescription('Manage ticket blacklist')\n  .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels)\n  .addSubcommand((subcommand) =>\n    subcommand\n      .setName('add')\n      .setDescription('Add a user to the blacklist')\n      .addUserOption((option) =>\n        option.setName('user').setDescription('User to blacklist').setRequired(true)\n      )\n      .addStringOption((option) =>\n        option.setName('reason').setDescription('Reason for blacklist').setRequired(false)\n      )\n  )\n  .addSubcommand((subcommand) =>\n    subcommand\n      .setName('remove')\n      .setDescription('Remove a user from the blacklist')\n      .addUserOption((option) =>\n        option.setName('user').setDescription('User to remove').setRequired(true)\n      )\n  )\n  .addSubcommand((subcommand) =>\n    subcommand.setName('list').setDescription('List all blacklisted users')\n  );\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    const config = ConfigHandler.getConfig();\n    const subcommand = interaction.options.getSubcommand();\n\n    if (subcommand === 'add') {\n      const user = interaction.options.getUser('user', true);\n      const reason = interaction.options.getString('reason') || 'No reason provided';\n\n      BlacklistManager.addUser(user, reason);\n\n      const embed = new EmbedBuilder()\n        .setTitle('‚úÖ User Blacklisted')\n        .setDescription(`**User:** ${user}\\n**Reason:** ${reason}`)\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed], ephemeral: true });\n      console.log(chalk.green(`‚úÖ ${user.tag} blacklisted by ${interaction.user.tag}`));\n    } else if (subcommand === 'remove') {\n      const user = interaction.options.getUser('user', true);\n      const removed = BlacklistManager.removeUser(user.id);\n\n      if (removed) {\n        const embed = new EmbedBuilder()\n          .setTitle('‚úÖ User Removed from Blacklist')\n          .setDescription(`**User:** ${user}`)\n          .setColor(config.embed_color)\n          .setFooter({ text: config.footer_text })\n          .setTimestamp();\n\n        await interaction.reply({ embeds: [embed], ephemeral: true });\n        console.log(chalk.green(`‚úÖ ${user.tag} removed from blacklist by ${interaction.user.tag}`));\n      } else {\n        await interaction.reply({\n          content: '‚ùå User is not blacklisted.',\n          ephemeral: true,\n        });\n      }\n    } else if (subcommand === 'list') {\n      const blacklist = BlacklistManager.getBlacklist();\n      const entries = Object.values(blacklist);\n\n      if (entries.length === 0) {\n        await interaction.reply({\n          content: 'üìã The blacklist is empty.',\n          ephemeral: true,\n        });\n        return;\n      }\n\n      const embed = new EmbedBuilder()\n        .setTitle('üìã Blacklisted Users')\n        .setDescription(\n          entries\n            .map(\n              (entry, index) =>\n                `**${index + 1}.** <@${entry.userId}> (${entry.userName})\\n` +\n                `   **Reason:** ${entry.reason}\\n` +\n                `   **Date:** ${new Date(entry.timestamp).toLocaleString()}`\n            )\n            .join('\\n\\n')\n        )\n        .setColor(config.embed_color)\n        .setFooter({ text: config.footer_text })\n        .setTimestamp();\n\n      await interaction.reply({ embeds: [embed], ephemeral: true });\n    }\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in blacklist command:'), error);\n    await interaction.reply({\n      content: '‚ùå An error occurred while processing the command.',\n      ephemeral: true,\n    });\n  }\n}\n","size_bytes":4005},"src/types/index.ts":{"content":"export interface TicketData {\n  ticketId: string;\n  channelId: string;\n  userId: string;\n  username: string;\n  category: string;\n  panelNumber: number;\n  categoryIndex: number;\n  createdAt: number;\n  claimedBy?: string;\n  claimedByUsername?: string;\n  priority: TicketPriority;\n  tags: string[];\n  status: TicketStatus;\n  messages: TicketMessage[];\n  lastActivity: number;\n  inactivityWarned?: boolean;\n  rating?: number;\n  feedbackText?: string;\n}\n\nexport enum TicketPriority {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  URGENT = 'urgent',\n}\n\nexport enum TicketStatus {\n  OPEN = 'open',\n  CLAIMED = 'claimed',\n  CLOSED = 'closed',\n  DELETED = 'deleted',\n}\n\nexport interface TicketMessage {\n  authorId: string;\n  authorUsername: string;\n  content: string;\n  timestamp: number;\n  attachments?: string[];\n}\n\nexport interface LogEntry {\n  timestamp: number;\n  type: LogType;\n  ticketId?: string;\n  userId: string;\n  username: string;\n  details: string;\n  metadata?: any;\n}\n\nexport enum LogType {\n  TICKET_CREATED = 'ticket_created',\n  TICKET_CLOSED = 'ticket_closed',\n  TICKET_REOPENED = 'ticket_reopened',\n  TICKET_DELETED = 'ticket_deleted',\n  TICKET_CLAIMED = 'ticket_claimed',\n  TICKET_UNCLAIMED = 'ticket_unclaimed',\n  PRIORITY_CHANGED = 'priority_changed',\n  TAG_ADDED = 'tag_added',\n  TAG_REMOVED = 'tag_removed',\n  MEMBER_ADDED = 'member_added',\n  MEMBER_REMOVED = 'member_removed',\n  RATING_SUBMITTED = 'rating_submitted',\n}\n\nexport interface StatsData {\n  totalTickets: number;\n  openTickets: number;\n  closedTickets: number;\n  avgResponseTime: number;\n  avgResolutionTime: number;\n  avgRating: number;\n  ticketsByCategory: { [key: string]: number };\n  ticketsByStaff: { [key: string]: number };\n  ratingDistribution: { [key: number]: number };\n}\n\nexport interface Config {\n  token: string;\n  guild_id: string;\n  staff_roles: string[];\n  ticket_category_id: string;\n  feedback_channel_id: string;\n  transcript_channel_id: string;\n  log_channel_id?: string;\n  \n  // Branding & Appearance\n  embed_color: string;\n  footer_text: string;\n  bot_name: string;\n  thumbnail_url?: string;\n  banner_url?: string;\n  \n  // Language\n  language: string;\n  \n  // Features\n  features: {\n    ai_responses: boolean;\n    auto_close: boolean;\n    working_hours: boolean;\n    ticket_reviews: boolean;\n    transcripts: boolean;\n    addons: boolean;\n  };\n  \n  // Automation\n  automation: {\n    inactivity_timeout: number; // minutes\n    inactivity_warning: number; // minutes before timeout\n    staff_reminder_timeout: number; // minutes\n    max_tickets_per_user: number;\n    ticket_overload_limit: number;\n  };\n  \n  // Working Hours\n  working_hours: {\n    enabled: boolean;\n    timezone: string;\n    schedule: {\n      monday: { start: string; end: string; enabled: boolean };\n      tuesday: { start: string; end: string; enabled: boolean };\n      wednesday: { start: string; end: string; enabled: boolean };\n      thursday: { start: string; end: string; enabled: boolean };\n      friday: { start: string; end: string; enabled: boolean };\n      saturday: { start: string; end: string; enabled: boolean };\n      sunday: { start: string; end: string; enabled: boolean };\n    };\n  };\n  \n  // Transcripts\n  transcripts: {\n    format: 'html' | 'txt' | 'both';\n    send_to_user: boolean;\n    send_to_staff_log: boolean;\n    include_attachments: boolean;\n  };\n  \n  // AI Settings\n  ai: {\n    enabled: boolean;\n    provider?: string;\n    api_key?: string;\n    model?: string;\n    auto_respond_delay?: number;\n  };\n  \n  // Priority Colors\n  priority_colors: {\n    low: string;\n    medium: string;\n    high: string;\n    urgent: string;\n  };\n  \n  // Custom Tags\n  available_tags: string[];\n}\n\nexport interface PanelCategory {\n  label: string;\n  description: string;\n  emoji: string;\n  modal: {\n    title: string;\n    questions: ModalQuestion[];\n  };\n}\n\nexport interface ModalQuestion {\n  label: string;\n  style: 'short' | 'paragraph';\n  required: boolean;\n  placeholder?: string;\n  min_length?: number;\n  max_length?: number;\n}\n\nexport interface Panel {\n  title: string;\n  description: string;\n  color: string;\n  footer: string;\n  emoji: string;\n  thumbnail?: string;\n  image?: string;\n  author?: {\n    name: string;\n    icon_url?: string;\n  };\n  categories: PanelCategory[];\n}\n\nexport interface Panels {\n  panels: {\n    [key: number]: Panel;\n  };\n}\n","size_bytes":4334},"src/commands/reload.ts":{"content":"import {\n  SlashCommandBuilder,\n  ChatInputCommandInteraction,\n  PermissionFlagsBits,\n  EmbedBuilder,\n} from 'discord.js';\nimport { ConfigHandler } from '../utils/configHandler.js';\nimport chalk from 'chalk';\n\nexport const data = new SlashCommandBuilder()\n  .setName('reload')\n  .setDescription('Reload configuration files without restarting the bot')\n  .setDefaultMemberPermissions(PermissionFlagsBits.Administrator);\n\nexport async function execute(interaction: ChatInputCommandInteraction) {\n  try {\n    await interaction.reply({\n      content: '‚åõ Reloading configuration...',\n      ephemeral: true,\n    });\n\n    ConfigHandler.reload();\n\n    const config = ConfigHandler.getConfig();\n\n    const embed = new EmbedBuilder()\n      .setTitle('‚úÖ Configuration Reloaded')\n      .setDescription(\n        'All configuration files have been reloaded successfully.\\n\\n' +\n          '**Reloaded:**\\n‚Ä¢ config.yml\\n‚Ä¢ ticket-panels.yml'\n      )\n      .setColor(config.embed_color)\n      .setFooter({ text: config.footer_text })\n      .setTimestamp();\n\n    await interaction.editReply({ content: '', embeds: [embed] });\n    console.log(chalk.green(`‚úÖ Configuration reloaded by ${interaction.user.tag}`));\n  } catch (error) {\n    console.error(chalk.red('‚ùå Error in reload command:'), error);\n    await interaction.editReply({\n      content: '‚ùå An error occurred while reloading the configuration.',\n    });\n  }\n}\n","size_bytes":1414},"src/utils/envLoader.ts":{"content":"import * as fs from 'fs';\nimport * as path from 'path';\nimport chalk from 'chalk';\n\nexport class EnvLoader {\n  private static loaded = false;\n\n  static load(): void {\n    if (this.loaded) {\n      return;\n    }\n\n    const envPath = path.join(process.cwd(), '.env');\n    \n    if (!fs.existsSync(envPath)) {\n      console.log(chalk.yellow('‚ö†Ô∏è No .env file found. Using config.yml values or defaults.'));\n      console.log(chalk.yellow('   For production, copy .env.example to .env and configure it.'));\n      this.loaded = true;\n      return;\n    }\n\n    try {\n      const envFile = fs.readFileSync(envPath, 'utf8');\n      const lines = envFile.split('\\n');\n\n      for (const line of lines) {\n        // Skip empty lines and comments\n        if (!line.trim() || line.trim().startsWith('#')) {\n          continue;\n        }\n\n        // Parse KEY=VALUE\n        const match = line.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);\n        if (match) {\n          const [, key, value] = match;\n          // Only set if not already set (allows override from actual env vars)\n          if (!process.env[key]) {\n            process.env[key] = value.trim();\n          }\n        }\n      }\n\n      console.log(chalk.green('‚úÖ Environment variables loaded from .env'));\n      this.loaded = true;\n    } catch (error) {\n      console.error(chalk.red('‚ùå Error loading .env file:'), error);\n      this.loaded = true;\n    }\n  }\n\n  static get(key: string, defaultValue?: string): string | undefined {\n    return process.env[key] || defaultValue;\n  }\n\n  static getRequired(key: string): string {\n    const value = process.env[key];\n    if (!value) {\n      throw new Error(`Required environment variable ${key} is not set`);\n    }\n    return value;\n  }\n\n  static getBoolean(key: string, defaultValue: boolean = false): boolean {\n    const value = process.env[key];\n    if (!value) {\n      return defaultValue;\n    }\n    return value.toLowerCase() === 'true' || value === '1';\n  }\n\n  static getNumber(key: string, defaultValue: number = 0): number {\n    const value = process.env[key];\n    if (!value) {\n      return defaultValue;\n    }\n    const num = parseInt(value, 10);\n    return isNaN(num) ? defaultValue : num;\n  }\n\n  static getArray(key: string, defaultValue: string[] = []): string[] {\n    const value = process.env[key];\n    if (!value) {\n      return defaultValue;\n    }\n    return value.split(',').map(v => v.trim()).filter(v => v.length > 0);\n  }\n}\n","size_bytes":2429}},"version":2}